<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Verif_sumarray: Introduction to Verifiable C</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/vc.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 5beta: Verifiable C</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>Table of Contents</li></a>
   <a href='coqindex.html'><li class='section_name'>Index</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">Verif_sumarray<span class="subtitle">Introduction to Verifiable C</span></h1>


<div class="doc">

<div class="paragraph"> </div>

 This chapter is a quick guided tour of some basic features
  of Verifiable C.  You can also see specific chapters of the 
  Verifiable C Reference Manual, <span class="inlinecode"><span class="id" type="var">vst</span>/<span class="id" type="var">doc</span>/<span class="id" type="var">VC.pdf</span></span> in your VST installation;
  that document is mentioned in the "SEE ALSO" references here.
<div class="paragraph"> </div>

<a name="lab9"></a><h2 class="section">Here is a little C program, <span class="inlinecode"><span class="id" type="var">sumarray.c</span></span></h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<pre>
#include &lt;stddef.h&gt;

unsigned sumarray(unsigned a[], int n) {
  int i; unsigned s;
  i=0;
  s=0;
  while (i&lt;n) {
    s+=a[i];
    i++;
  }
  return s;
}

unsigned four[4] = {1,2,3,4};

int main(void) {
  unsigned int s;
  s = sumarray(four,4);
  return (int)s;
}
</pre>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab10"></a><h2 class="section">Workflow</h2>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 3 (Workflow), 
     Chapter 4 (<i>Verifiable C and clightgen</i>), Chapter 5 (<i>ASTs</i>) 
<div class="paragraph"> </div>

 To verify a C program, such as <span class="inlinecode"><span class="id" type="var">sumarray.c</span></span>, use the CompCert
  front end to parse it into an Abstract Syntax Tree (AST).  Do this by
<pre>
   clightgen -normalize sumarray.c
</pre>
  <span class="inlinecode"><span class="id" type="var">clightgen</span></span> is one of the CompCert tools, built by mentioning
  the -clightgen option when you run ./configure when building CompCert.

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">clightgen</span></span> will produce a file <span class="inlinecode"><span class="id" type="var">sumarray.v</span></span> that contains the Coq
  inductive data structure describing the syntax trees of the source
  program.  You can open <span class="inlinecode"><span class="id" type="var">sumarray.v</span></span> in the current directory
  and inspect it.  (No need to run clightgen yourself on these 
  exercises, we have done it for you.)

<div class="paragraph"> </div>

<a name="lab11"></a><h2 class="section">Let's verify!</h2>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 7 (<i>Functional model, API spec</i>) 
<div class="paragraph"> </div>

 This file, <span class="inlinecode"><span class="id" type="var">Verif_sumarray.v</span></span>, contains a <i>specification</i>
  of the functional correctness of the program <span class="inlinecode"><span class="id" type="var">sumarray.c</span></span>,
  followed by a proof that the program satisfies its specification.

<div class="paragraph"> </div>

 For larger programs, one would typically break this down into three
 or more files:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Functional model (often in the form of a Coq function)

</li>
<li> API specification

</li>
<li> Function-body correctness proofs, one per file.

</li>
</ul>
 
<div class="paragraph"> </div>

<a name="lab12"></a><h3 class="section">Standard boilerplace</h3>

<div class="paragraph"> </div>

 Every API specification begins with the same standard boilerplate;
    the only thing that changes is the name of the program, in this
    case <span class="inlinecode"><span class="id" type="var">sumarray</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">VST.floyd.proofauto</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">VC.sumarray</span>.<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">CompSpecs</span> : <span class="id" type="var">compspecs</span>. <span class="id" type="var">make_compspecs</span> <span class="id" type="var">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Vprog</span> : <span class="id" type="var">varspecs</span>. <span class="id" type="var">mk_varspecs</span> <span class="id" type="var">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
</div>

<div class="doc">
The first line imports Verifiable C and its <i>Floyd</i> proof-automation
    library.  The second line imports the AST of the program to be verified.
    The third line processes all the struct and union definitions
    in the AST, and the fourth line processes global variable declarations. 
<div class="paragraph"> </div>

<a name="lab13"></a><h3 class="section">Functional model</h3>

<div class="paragraph"> </div>

 To prove correctness of <span class="inlinecode"><span class="id" type="var">sumarray.c</span></span>, we start by writing a 
   <i>functional model</i> of adding up a sequence.  We can use a list-fold
   to express the sum of all the elements in a list of integers:

</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">sum_Z</span> : <span class="id" type="var">list</span> <span class="id" type="var">Z</span> â†’ <span class="id" type="var">Z</span> := <span class="id" type="var">fold_right</span> <span class="id" type="var">Z.add</span> 0.<br/>
</div>

<div class="doc">
Then we prove properties of the functional model; in this case,
    how <span class="inlinecode"><span class="id" type="var">sum_Z</span></span> interacts with list append. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">sum_Z_app</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">a</span> <span class="id" type="var">b</span>, <span class="id" type="var">sum_Z</span> (<span class="id" type="var">a</span>++<span class="id" type="var">b</span>) =  <span class="id" type="var">sum_Z</span> <span class="id" type="var">a</span> + <span class="id" type="var">sum_Z</span> <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">a</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The data types used in a functional model can be any kind of mathematics
  at all, as long as we have a way to relate them to the integers, tuples, 
  and sequences used in a C program.  But the mathematical integers <span class="inlinecode"><span class="id" type="var">Z</span></span> 
  and the 32-bit modular integers <span class="inlinecode"><span class="id" type="var">Int.int</span></span> are often relevant.
  Notice that this functional spec does not depend on <span class="inlinecode"><span class="id" type="var">sumarray.v</span></span> or on
  anything in the Verifiable C libraries. This is typical, and desirable:
  the functional model is about mathematics, not about C programming. 
<div class="paragraph"> </div>

<a name="lab14"></a><h2 class="section">API spec for the sumarray.c program</h2>

<div class="paragraph"> </div>

 The Application Programmer Interface (API) of a C program is expressed
 in its header file: function prototypes and data-structure definitions that 
 explain how to call upon the modules' functionality. In Verifiable C, an 
 <i>API specification</i> is written as a series of <i>function specifications</i> 
 (<span class="inlinecode"><span class="id" type="var">funspec</span></span>s) corresponding to the function prototypes. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">sumarray_spec</span> : <span class="id" type="var">ident</span> * <span class="id" type="var">funspec</span> :=<br/>
&nbsp;<span class="id" type="var">DECLARE</span> <span class="id" type="var">_sumarray</span><br/>
&nbsp;&nbsp;<span class="id" type="var">WITH</span> <span class="id" type="var">a</span>: <span class="id" type="var">val</span>, <span class="id" type="var">sh</span> : <span class="id" type="var">share</span>, <span class="id" type="var">contents</span> : <span class="id" type="var">list</span> <span class="id" type="var">Z</span>, <span class="id" type="var">size</span>: <span class="id" type="var">Z</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span> [ <span class="id" type="var">_a</span> <span class="id" type="var">OF</span> (<span class="id" type="var">tptr</span> <span class="id" type="var">tuint</span>), <span class="id" type="var">_n</span> <span class="id" type="var">OF</span> <span class="id" type="var">tint</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span>  (<span class="id" type="var">readable_share</span> <span class="id" type="var">sh</span>; 0 â‰¤ <span class="id" type="var">size</span> â‰¤ <span class="id" type="var">Int.max_signed</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Forall</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> â‡’ 0 â‰¤ <span class="id" type="var">x</span> â‰¤ <span class="id" type="var">Int.max_unsigned</span>) <span class="id" type="var">contents</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_a</span> <span class="id" type="var">a</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_n</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> <span class="id" type="var">size</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span>   (<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tuint</span> <span class="id" type="var">size</span>) (<span class="id" type="var">map</span> <span class="id" type="var">Vint</span> (<span class="id" type="var">map</span> <span class="id" type="var">Int.repr</span> <span class="id" type="var">contents</span>)) <span class="id" type="var">a</span>)<br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ <span class="id" type="var">tuint</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> () <span class="id" type="var">LOCAL</span>(<span class="id" type="var">temp</span> <span class="id" type="var">ret_temp</span>  (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> (<span class="id" type="var">sum_Z</span> <span class="id" type="var">contents</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tuint</span> <span class="id" type="var">size</span>) (<span class="id" type="var">map</span> <span class="id" type="var">Vint</span> (<span class="id" type="var">map</span> <span class="id" type="var">Int.repr</span> <span class="id" type="var">contents</span>)) <span class="id" type="var">a</span>).<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">ident</span>*<span class="id" type="var">funspec</span></span> begins, <span class="inlinecode"><span class="id" type="var">DECLARE</span></span> <span class="inlinecode"><span class="id" type="var">_sumarray</span></span>.  The Coq name
 <span class="inlinecode"><span class="id" type="var">_sumarray</span>:</span> <span class="inlinecode"><span class="id" type="var">ident</span></span> is an abbreviation for the positive number that
 CompCert uses to stand for this C identifier.  You can see the 
 Definition of <span class="inlinecode"><span class="id" type="var">_sumarray</span></span> near the beginning of <span class="inlinecode"><span class="id" type="var">sumarray.v</span></span>.  Later
 in <span class="inlinecode"><span class="id" type="var">sumarray.v</span></span>, you can see <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">f_sumarray</span></span> that is the
 C-language function body (represented as a syntax tree), and even
 later, near the end of the <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">global_definitions</span></span> you can
 see the binding of <span class="inlinecode"><span class="id" type="var">_sumarray</span></span> to <span class="inlinecode"><span class="id" type="var">f_sumarray</span></span>.

<div class="paragraph"> </div>

  A function is specified by its <i>precondition</i> and its
  <i>postcondition</i>.  The <span class="inlinecode"><span class="id" type="var">WITH</span></span> clause quantifies over Coq values that
  may appear in both the precondition and the postcondition. The
  precondition is parameterized by the C-language function parameters
  (in this case <span class="inlinecode"><span class="id" type="var">_a</span>,</span> <span class="inlinecode"><span class="id" type="var">_n</span></span>) and the postcondition is parameterized by a
  identifier <span class="inlinecode"><span class="id" type="var">ret_temp</span></span>, which is short for, ``the temporary variable
  holding the return value.''

<div class="paragraph"> </div>

  Function preconditions, postconditions, and loop invariants are
  <i>assertions</i> about the state of variables and memory at a particular
  program point.  In an assertion <span class="inlinecode"><span class="id" type="var">PROP</span>(<span class="id" type="var">P</span>)</span> <span class="inlinecode"><span class="id" type="var">LOCAL</span>(<span class="id" type="var">Q</span>)</span> <span class="inlinecode"><span class="id" type="var">SEP</span>(<span class="id" type="var">R</span>)</span>, the
  propositions in the sequence <span class="inlinecode"><span class="id" type="var">P</span></span> are all of Coq type <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>.  They
  describe things that are true independent of program state.  In the
  precondition above, the statement <span class="inlinecode">0</span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">size</span></span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">Int.max_signed</span></span> is 
  true <i>just within the scope of the quantification of the variable</i> 
  <span class="inlinecode"><span class="id" type="var">size</span></span>; that variable is bound by <span class="inlinecode"><span class="id" type="var">WITH</span></span>, and spans the <span class="inlinecode"><span class="id" type="var">PRE</span></span> and
  <span class="inlinecode"><span class="id" type="var">POST</span></span> assertions.

<div class="paragraph"> </div>

  The <span class="inlinecode"><span class="id" type="var">LOCAL</span></span> propositions <span class="inlinecode"><span class="id" type="var">Q</span></span> are <i>variable bindings</i> of type
  <span class="inlinecode"><span class="id" type="var">localdef</span></span>.  Here, the function-parameters <span class="inlinecode"><span class="id" type="var">a</span></span> and <span class="inlinecode"><span class="id" type="var">n</span></span> are treated
  as nonaddressable local variables, or ``temp'' variables.  The
  localdef <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_a</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> says that (in this program state) the contents
  of C local variable <span class="inlinecode"><span class="id" type="var">_a</span></span> is the Coq value <span class="inlinecode"><span class="id" type="var">a</span></span>.  

<div class="paragraph"> </div>

  In general, a C scalar variable holds something of type <span class="inlinecode"><span class="id" type="var">val</span></span>; this
  type is defined by CompCert as, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">val</span>.<br/>
<span class="comment">(*<br/>
&nbsp;Inductive&nbsp;val:&nbsp;Type&nbsp;:=&nbsp;&nbsp;<br/>
&nbsp;|&nbsp;Vundef:&nbsp;val&nbsp;&nbsp;<br/>
&nbsp;|&nbsp;Vint:&nbsp;int&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;val&nbsp;<br/>
&nbsp;|&nbsp;Vlong:&nbsp;int64&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;val<br/>
&nbsp;|&nbsp;Vfloat:&nbsp;float&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;val&nbsp;<br/>
&nbsp;|&nbsp;Vsingle:&nbsp;float32&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;val&nbsp;<br/>
&nbsp;|&nbsp;Vptr:&nbsp;block&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;ptrofs&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;val.&nbsp;*)</span><br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">SEP</span></span> conjuncts <span class="inlinecode"><span class="id" type="var">R</span></span> are <i>spatial assertions</i> in separation
  logic.  In this case, there's just one, a <span class="inlinecode"><span class="id" type="var">data_at</span></span> assertion saying
  that at address <span class="inlinecode"><span class="id" type="var">a</span></span> in memory, there is a data structure of type 
<pre>
  array[size] of unsigned int; 
</pre>
  with access-permission <span class="inlinecode"><span class="id" type="var">sh</span></span>, and the contents of that array is the
  sequence <span class="inlinecode"><span class="id" type="var">map</span></span> <span class="inlinecode"><span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">map</span></span> <span class="inlinecode"><span class="id" type="var">Int.repr</span></span> <span class="inlinecode"><span class="id" type="var">contents</span>)</span>.

<div class="paragraph"> </div>

  The postcondition is introduced by <span class="inlinecode"><span class="id" type="var">POST</span></span> <span class="inlinecode">[</span> <span class="inlinecode"><span class="id" type="var">tuint</span></span> <span class="inlinecode">]</span>, indicating that
  this function returns a value of type <span class="inlinecode"><span class="id" type="var">unsigned</span></span> <span class="inlinecode"><span class="id" type="var">int</span></span>. There are no
  <span class="inlinecode"><span class="id" type="var">PROP</span></span> statements in this postcondition&mdash;no forever-true facts hold
  now, that weren't already true on entry to the function.

<div class="paragraph"> </div>

  The <span class="inlinecode"><span class="id" type="var">LOCAL</span></span> clause <i>must not mention</i> the function parameters or
  local variables, because they are destroyed on function exit (and
  because your local variable names will not be meaningful to the
  function's caller).  The postcondition's <span class="inlinecode"><span class="id" type="var">LOCAL</span></span> will only mention 
  the return-temporary <span class="inlinecode"><span class="id" type="var">ret_temp</span></span>.

<div class="paragraph"> </div>

  The postcondition's <span class="inlinecode"><span class="id" type="var">SEP</span></span> clause mentions all the spatial resources
  from the precondition, minus ones that have been freed
  (deallocated), plus ones that have been malloc'd (allocated).

<div class="paragraph"> </div>

  So, overall, the specification for <span class="inlinecode"><span class="id" type="var">sumarray</span></span> is this: ``At any call
  to sumarray, there exist values <span class="inlinecode"><span class="id" type="var">a</span>,</span> <span class="inlinecode"><span class="id" type="var">sh</span>,</span> <span class="inlinecode"><span class="id" type="var">contents</span>,</span> <span class="inlinecode"><span class="id" type="var">size</span></span> such that
  <span class="inlinecode"><span class="id" type="var">sh</span></span> gives at least read-permission; <span class="inlinecode"><span class="id" type="var">size</span></span> is representable as a
  nonnegative 32-bit signed integer; function-parameter <span class="inlinecode"><span class="id" type="var">_a</span></span> contains
  value <span class="inlinecode"><span class="id" type="var">a</span></span> and <span class="inlinecode"><span class="id" type="var">_n</span></span> contains the 32-bit representation of <span class="inlinecode"><span class="id" type="var">size</span></span>; and
  there's an array in memory at address <span class="inlinecode"><span class="id" type="var">a</span></span> with permission <span class="inlinecode"><span class="id" type="var">sh</span></span>
  containing <span class="inlinecode"><span class="id" type="var">contents</span></span>.  The function returns a value equal to
  <span class="inlinecode"><span class="id" type="var">sum_int</span>(<span class="id" type="var">contents</span>)</span>, and leaves the array in memory unaltered.''  
<div class="paragraph"> </div>

<a name="lab15"></a><h3 class="section">Function specification for main()</h3>

<div class="paragraph"> </div>

 The function-spec for <span class="inlinecode"><span class="id" type="var">main</span></span> has a special form, which we discuss
   below at the heading, <i>Global variables and main</i> .  In particular,
   its precondition is defined using <span class="inlinecode"><span class="id" type="var">main_pre</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">main_spec</span> :=<br/>
&nbsp;<span class="id" type="var">DECLARE</span> <span class="id" type="var">_main</span><br/>
&nbsp;&nbsp;<span class="id" type="var">WITH</span> <span class="id" type="var">gv</span> : <span class="id" type="var">globals</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span>  [] <span class="id" type="var">main_pre</span> <span class="id" type="var">prog</span> <span class="id" type="var">nil</span> <span class="id" type="var">gv</span><br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ <span class="id" type="var">tint</span> ]  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span>() <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">ret_temp</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> (1+2+3+4)))) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span>(<span class="id" type="var">TT</span>).<br/>
</div>

<div class="doc">
This postcondition says, we have indeed added up the global array
   <span class="inlinecode"><span class="id" type="var">four</span></span>. 
<div class="paragraph"> </div>

<a name="lab16"></a><h3 class="section">Integer overflow.</h3>
 In Verifiable C's signed integer arithmetic, you must prove (if the 
 system cannot prove automatically) that no overflow occurs.  In unsigned
 integers, arithmetic is treated as modulo-2^n (where n is typically 32 
 or 64), and overflow is not an issue.  The function <span class="inlinecode"><span class="id" type="var">Int.repr</span>:</span> <span class="inlinecode"><span class="id" type="var">Z</span></span> <span class="inlinecode">â†’</span> <span class="inlinecode"><span class="id" type="var">int</span></span>
 truncates mathematical integers into 32-bit integers by taking the 
 (sign-extended) low-order 32 bits.  <span class="inlinecode"><span class="id" type="var">Int.signed</span>:</span> <span class="inlinecode"><span class="id" type="var">int</span></span> <span class="inlinecode">â†’</span> <span class="inlinecode"><span class="id" type="var">Z</span></span> injects back
 into the signed integers.

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="var">sumarray</span></span> program uses unsigned arithmetic for <span class="inlinecode"><span class="id" type="var">s</span></span> and the
 array contents, and uses signed arithmetic for <span class="inlinecode"><span class="id" type="var">i</span></span>.

<div class="paragraph"> </div>

 The postcondition guarantees that the value returned is 
 <span class="inlinecode"><span class="id" type="var">Int.repr</span></span> <span class="inlinecode">(<span class="id" type="var">sum_Z</span></span> <span class="inlinecode"><span class="id" type="var">contents</span>)</span>.  But what if the sum of all the <span class="inlinecode"><span class="id" type="var">s</span></span>
 is larger than 2^32, so the sum doesn't fit in a 32-bit signed integer?
 Then <span class="inlinecode"><span class="id" type="var">Int.unsigned</span>(<span class="id" type="var">Int.repr</span></span> <span class="inlinecode">(<span class="id" type="var">sum_Z</span></span> <span class="inlinecode"><span class="id" type="var">contents</span>))</span> <span class="inlinecode">â‰ </span> <span class="inlinecode"><span class="id" type="var">sum_Z</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span>.
 In general, for a claim about <span class="inlinecode"><span class="id" type="var">Int.repr</span>(<span class="id" type="var">x</span>)</span> to be <i>useful</i> one also
 needs that <span class="inlinecode">0</span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">Int.max_unsigned</span></span> or 
 <span class="inlinecode"><span class="id" type="var">Int.min_signed</span></span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">Int.max_signed</span></span>.
 The caller of <span class="inlinecode"><span class="id" type="var">sumarray</span></span> will probably need to prove 
 <span class="inlinecode">0</span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">sum_Z</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">Int.max_unsigned</span></span>
 in order to make much use of the postcondition. 
<div class="paragraph"> </div>

<a name="lab17"></a><h2 class="section">Packaging the Gprog and Vprog</h2>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 8 (<i>Proof of the sumarray program</i>) 
<div class="paragraph"> </div>

 To prove the correctness of a whole program, 
  1. Collect the function-API specs together into <span class="inlinecode"><span class="id" type="var">Gprog</span></span>.
  2. Prove that each function satisfies its own API spec
    (with a <span class="inlinecode"><span class="id" type="var">semax_body</span></span> proof).
  3. Tie everything together with a <span class="inlinecode"><span class="id" type="var">semax_func</span></span> proof.

<div class="paragraph"> </div>

The first step is easy: 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;Packaging&nbsp;the&nbsp;API&nbsp;specs&nbsp;all&nbsp;together.&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Gprog</span> := <span class="id" type="var">ltac</span>:(<span class="id" type="var">with_library</span> <span class="id" type="var">prog</span> [<span class="id" type="var">sumarray_spec</span>; <span class="id" type="var">main_spec</span>]).<br/>
</div>

<div class="doc">
What's in <span class="inlinecode"><span class="id" type="var">Gprog</span></span> are the funspecs that we built using <span class="inlinecode"><span class="id" type="var">DECLARE</span></span>, 
  <i>in addition to</i> some other funspecs that are part of the standard library.
  The tactic <span class="inlinecode"><span class="id" type="var">with_library</span></span> augments the user-provided list with
  these additional specifications.
  (See also: the <span class="inlinecode"><span class="id" type="var">with_library</span></span> chapter of VC.pdf)  
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">Gprog</span>. <span class="comment">(*&nbsp;Quite&nbsp;long,&nbsp;and&nbsp;not&nbsp;interesting,&nbsp;but&nbsp;note&nbsp;that&nbsp;the&nbsp;last<br/>
&nbsp;&nbsp;bindings&nbsp;in&nbsp;the&nbsp;list&nbsp;are&nbsp;the&nbsp;two&nbsp;<span class="inlinecode"><span class="id" type="var">DECLARE</span></span>s&nbsp;for&nbsp;<span class="inlinecode"><span class="id" type="var">_sumarray</span></span>&nbsp;and&nbsp;<span class="inlinecode"><span class="id" type="var">_main</span></span>.&nbsp;*)</span><br/>
</div>

<div class="doc">
In addition to <span class="inlinecode"><span class="id" type="var">Gprog</span></span>, the API spec contains <span class="inlinecode"><span class="id" type="var">Vprog</span></span>, the list of
  global-variable type-specs.  This was computed automatically by the
  <span class="inlinecode"><span class="id" type="var">mk_varspecs</span></span> tactic, in the "boilerplate" code above. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Print</span> <span class="id" type="var">Vprog</span>.<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;=&nbsp;<span class="inlinecode">(<span class="id" type="var">_four</span>,</span> <span class="inlinecode"><span class="id" type="var">tarray</span></span> <span class="inlinecode"><span class="id" type="var">tuint</span></span> <span class="inlinecode">4)</span>&nbsp;&nbsp;:&nbsp;varspecs&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">varspecs</span>.<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;=&nbsp;list&nbsp;(ident&nbsp;*&nbsp;type)&nbsp;*)</span><br/>
</div>

<div class="doc">
That is, for each C language global variable, <span class="inlinecode"><span class="id" type="var">Vprog</span></span> gives its
  name and its C-language type. 
<div class="paragraph"> </div>

<a name="lab18"></a><h2 class="section">Proof of the sumarray program</h2>

<div class="paragraph"> </div>

 Now comes the proof that <span class="inlinecode"><span class="id" type="var">f_sumarray</span></span>, the body of the <span class="inlinecode"><span class="id" type="var">sumarray</span>()</span>
   function, satisfies <span class="inlinecode"><span class="id" type="var">sumarray_spec</span></span>, in the global context <span class="inlinecode">(<span class="id" type="var">Vprog</span>,<span class="id" type="var">Gprog</span>)</span>.

</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_sumarray</span>: <span class="id" type="var">semax_body</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span> <span class="id" type="var">f_sumarray</span> <span class="id" type="var">sumarray_spec</span>.<br/>
</div>

<div class="doc">
Here, <span class="inlinecode"><span class="id" type="var">f_sumarray</span></span> is the actual function body (AST of the C code) 
  as parsed by <span class="inlinecode"><span class="id" type="var">clightgen</span></span>; you can read it in <span class="inlinecode"><span class="id" type="var">sumarray.v</span></span>.
  You can read <span class="inlinecode"><span class="id" type="var">body_sumarray</span></span> as claiming: In the context of <span class="inlinecode"><span class="id" type="var">Vprog</span></span> and
  <span class="inlinecode"><span class="id" type="var">Gprog</span></span>, the function body <span class="inlinecode"><span class="id" type="var">f_sumarray</span></span> satisfies its specification 
  <span class="inlinecode"><span class="id" type="var">sumarray_spec</span></span>.  We need the context in case the sumarray function
  refers to a global variable (<span class="inlinecode"><span class="id" type="var">Vprog</span></span> provides the variable's type)
  or calls a global function  (<span class="inlinecode"><span class="id" type="var">Gprog</span></span> provides the function's API spec). 
<div class="paragraph"> </div>

 Now, the proof of <span class="inlinecode"><span class="id" type="var">body_sumarray</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Proof</span>.<br/>
</div>

<div class="doc">
<a name="lab19"></a><h3 class="section">start_function</h3>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 9 (<i>start_function</i>) 
<div class="paragraph"> </div>

 The predicate <span class="inlinecode"><span class="id" type="var">semax_body</span></span> states the Hoare triple of the function body,
 <span class="inlinecode"><span class="id" type="var">Delta</span></span> <span class="inlinecode">&#x22A2;</span> <span class="inlinecode">{<span class="id" type="var">Pre</span>}</span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode">{<span class="id" type="var">Post</span>}</span>, where <span class="inlinecode"><span class="id" type="var">Pre</span></span> and <span class="inlinecode"><span class="id" type="var">Post</span></span> are taken from the
 <span class="inlinecode"><span class="id" type="var">funspec</span></span>, <span class="inlinecode"><span class="id" type="var">c</span></span> is the body of the function, and the type-context <span class="inlinecode"><span class="id" type="var">Delta</span></span>
 is calculated from the global type-context overlaid with the parameter- 
 and local-types of the function.

<div class="paragraph"> </div>

 To prove this, we begin with the tactic <span class="inlinecode"><span class="id" type="var">start_function</span></span>,  which takes care
 of some simple bookkeeping and expresses the Hoare triple to be proved. 
</div>
<div class="code code-tight">

<span class="id" type="var">start_function</span>. <span class="comment">(*&nbsp;Always&nbsp;do&nbsp;this&nbsp;at&nbsp;the&nbsp;beginning&nbsp;of&nbsp;a&nbsp;semax_body&nbsp;proof&nbsp;*)</span><br/>
</div>

<div class="doc">
Some of the assumptions you now see above the line are,

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">a</span>,</span> <span class="inlinecode"><span class="id" type="var">sh</span>,</span> <span class="inlinecode"><span class="id" type="var">contents</span>,</span> <span class="inlinecode"><span class="id" type="var">size</span></span>, taken directly from the WITH clause 
       of <span class="inlinecode"><span class="id" type="var">sumarray_spec</span></span>;

</li>
<li> <span class="inlinecode"><span class="id" type="var">Delta_specs</span></span>, the context in which Floyd's proof tactics will look up
       the specifications of global functions;

</li>
<li> <span class="inlinecode"><span class="id" type="var">Delta</span></span>, the context in which Floyd will look up the types of 
       local and global variables;

</li>
<li> <span class="inlinecode"><span class="id" type="var">SH</span>,<span class="id" type="var">H</span>,<span class="id" type="var">H<sub>0</sub></span></span>, taken exactly from the <span class="inlinecode"><span class="id" type="var">PROP</span></span> clauses of <span class="inlinecode"><span class="id" type="var">sumarray_spec</span></span>'s
       precondition.

</li>
</ul>
  There are also two <i>abbreviations</i> above the line,
  <span class="inlinecode"><span class="id" type="var">POSTCONDITION</span></span> and <span class="inlinecode"><span class="id" type="var">MORE_COMMANDS</span></span>, discussed below.

<div class="paragraph"> </div>

<a name="lab20"></a><h3 class="section">Forward symbolic execution</h3>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 10 (<i>forward</i>). 
<div class="paragraph"> </div>

 We do Hoare logic proof by forward symbolic execution.
    At the beginning of this function body, our proof goal is
    a Hoare triple about the statement <span class="inlinecode">(<span class="id" type="var">i</span>=0;</span> <span class="inlinecode">...<span class="id" type="var">more</span></span> <span class="inlinecode"><span class="id" type="var">commands</span>...)</span>.
    In a forward Hoare logic proof of <span class="inlinecode">{<span class="id" type="var">P</span>}(<span class="id" type="var">i</span>=0;...<span class="id" type="var">more</span>...){<span class="id" type="var">R</span>}</span> 
    we might first apply the sequence rule,
<pre>
    {P}(i=0;){Q}  {Q}(...more...){R}
    ---------------------------------
    {P}(i=0;...more...){R}
</pre>
assuming we could derive some appropriate assertion <span class="inlinecode"><span class="id" type="var">Q</span></span>.
For many kinds of statements (assignments, return, break,
continue) <span class="inlinecode"><span class="id" type="var">Q</span></span> is derived automatically by the <span class="inlinecode"><span class="id" type="var">forward</span></span> tactic, 
which applies a strongest-postcondition style of proof rule.
Let us now apply the <span class="inlinecode"><span class="id" type="var">forward</span></span> tactic: 
</div>
<div class="code code-tight">

<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;i&nbsp;=&nbsp;0;&nbsp;*)</span><br/>
</div>

<div class="doc">
Look at the precondition of the current proof goal, that is,
  the second argument of <span class="inlinecode"><span class="id" type="var">semax</span></span>; it has the form 
  <span class="inlinecode"><span class="id" type="var">PROP</span>(...)</span> <span class="inlinecode"><span class="id" type="var">LOCAL</span>(...)</span> <span class="inlinecode"><span class="id" type="var">SEP</span>(...)</span>.  That precondition is also
  the <i>postcondition</i> of <span class="inlinecode"><span class="id" type="var">i</span>=0;</span>.  It's much like the
  <i>precondition</i> of <span class="inlinecode"><span class="id" type="var">i</span>=0;</span> except for one change:  we now know that <span class="inlinecode"><span class="id" type="var">i</span></span>
  is equal to <span class="inlinecode">0</span>, which is expressed in the <span class="inlinecode"><span class="id" type="var">LOCAL</span></span> part as 
  <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_i</span></span> <span class="inlinecode">(<span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">Int.repr</span></span> <span class="inlinecode">0))</span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> 0. <span class="comment">(*&nbsp;:&nbsp;Z,&nbsp;&nbsp;&nbsp;the&nbsp;mathematical&nbsp;integer&nbsp;zero.&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">Int.repr</span> 0). <span class="comment">(*&nbsp;:&nbsp;int,&nbsp;&nbsp;&nbsp;the&nbsp;32-bit&nbsp;integer&nbsp;representing&nbsp;0.&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> 0)). <span class="comment">(*&nbsp;:&nbsp;val,&nbsp;&nbsp;&nbsp;the&nbsp;type&nbsp;of&nbsp;CompCert&nbsp;values&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_i</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> 0))). <span class="comment">(*&nbsp;:&nbsp;localdef,&nbsp;&nbsp;the&nbsp;type&nbsp;of&nbsp;LOCAL&nbsp;assertions&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab21"></a><h3 class="section">abbreviate, MORE_COMMANDS, POSTCONDITION</h3>
  When doing forward symbolic execution (forward Floyd/Hoare proof)
  through a large function, you don't usually want to see the entire
  function-body in your proof subgoal.  Therefore the system abbreviates
  some things for you, using the magic of Coq's implicit arguments. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> @<span class="id" type="var">abbreviate</span>.<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;A&nbsp;:&nbsp;Type,&nbsp;A&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;A&nbsp;*)</span><br/>
<span class="id" type="var">About</span> <span class="id" type="var">abbreviate</span>.<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;Arguments&nbsp;A,&nbsp;x&nbsp;are&nbsp;implicit&nbsp;and&nbsp;maximally&nbsp;inserted&nbsp;&nbsp;.&nbsp;.&nbsp;.&nbsp;*)</span><br/>
</div>

<div class="doc">
We see here that <span class="inlinecode"><span class="id" type="var">abbreviate</span></span> is just the identity function,
   with <i>both</i> of its arguments implicit! 
<div class="paragraph"> </div>

 To examine the actual contents of MORE_COMMANDS, just do this: 
</div>
<div class="code code-tight">

<span class="id" type="tactic">unfold</span> <span class="id" type="var">abbreviate</span> <span class="id" type="keyword">in</span> <span class="id" type="var">MORE_COMMANDS</span>.<br/>
</div>

<div class="doc">
or alternately, 
</div>
<div class="code code-tight">
<span class="id" type="tactic">subst</span> <span class="id" type="var">MORE_COMMANDS</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">abbreviate</span>.<br/>
</div>

<div class="doc">
Similarly, to see the POSTCONDITION, just do, 
</div>
<div class="code code-tight">

<span class="id" type="tactic">unfold</span> <span class="id" type="var">abbreviate</span> <span class="id" type="keyword">in</span> <span class="id" type="var">POSTCONDITION</span>.<br/>
</div>

<div class="doc">
<a name="lab22"></a><h3 class="section">Hint</h3>
 In any VST proof state, the <span class="inlinecode"><span class="id" type="var">hint</span></span> tactic will print a suggestion 
  (if it can) that will help you make progress in the proof.
  In stepping through the case study in this chapter,
  insert <span class="inlinecode"><span class="id" type="var">hint</span></span> at any point to see what it says. 
</div>
<div class="code code-tight">

<span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
Then delete the hints!  They slow down replay of your proof. 
<div class="paragraph"> </div>

 The hint suggests using <span class="inlinecode"><span class="id" type="var">abbreviate_semax</span></span>, which will undo
  the <span class="inlinecode"><span class="id" type="tactic">unfold</span></span> <span class="inlinecode"><span class="id" type="var">abbreviate</span></span> that we did above.  Really this is optional;
  if we don't do <span class="inlinecode"><span class="id" type="var">abbreviate_semax</span></span>, the next <span class="inlinecode"><span class="id" type="var">forward</span></span> tactic will
  do it for us. 
</div>
<div class="code code-tight">

<span class="id" type="var">abbreviate_semax</span>.<br/>
<span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
This time, the hint suggests, try 'forward'. 
<div class="paragraph"> </div>

<a name="lab23"></a><h3 class="section">Forward through another assignment statement.</h3>

</div>
<div class="code code-space">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;s&nbsp;=&nbsp;0;&nbsp;*)</span><br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">forward</span></span> tactic works on assignment statements, break, 
   continue, and return. 
<div class="paragraph"> </div>

<a name="lab24"></a><h3 class="section">While loops, forward_while</h3>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 12 (<i>if, while, for</i>) and Chapter 13 (<i>while loops</i>). 
<div class="paragraph"> </div>

 To do symbolic execution through a <span class="inlinecode"><span class="id" type="var">while</span></span> loop, use the
   <span class="inlinecode"><span class="id" type="var">forward_while</span></span> tactic; you must supply a loop invariant. 
</div>
<div class="code code-tight">
<span class="id" type="var">forward_while</span><br/>
&nbsp;(<span class="id" type="var">EX</span> <span class="id" type="var">i</span>: <span class="id" type="var">Z</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span>  (0 â‰¤ <span class="id" type="var">i</span> â‰¤ <span class="id" type="var">size</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_a</span> <span class="id" type="var">a</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">temp</span> <span class="id" type="var">_i</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> <span class="id" type="var">i</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">temp</span> <span class="id" type="var">_n</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> <span class="id" type="var">size</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">temp</span> <span class="id" type="var">_s</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> (<span class="id" type="var">sum_Z</span> (<span class="id" type="var">sublist</span> 0 <span class="id" type="var">i</span> <span class="id" type="var">contents</span>)))))<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span>   (<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tuint</span> <span class="id" type="var">size</span>) (<span class="id" type="var">map</span> <span class="id" type="var">Vint</span> (<span class="id" type="var">map</span> <span class="id" type="var">Int.repr</span> <span class="id" type="var">contents</span>)) <span class="id" type="var">a</span>)).<br/>
</div>

<div class="doc">
A loop invariant is an assertion, almost always in the form
  of an existential quantifier,  <span class="inlinecode"><span class="id" type="var">EX</span>...<span class="id" type="var">PROP</span>(...)<span class="id" type="var">LOCAL</span>(...)<span class="id" type="var">SEP</span>(...)</span>.
  Each iteration of the loop has a state characterized by
  a different value of some iteration variable(s),
  the <span class="inlinecode"><span class="id" type="var">EX</span></span> binds that value.

<div class="paragraph"> </div>

  <span class="inlinecode"><span class="id" type="var">forward_while</span></span> leaves four subgoals; here we label them
   with the * bullet. 
</div>
<div class="code code-tight">
* <span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
The first subgoal is to prove 
  that the current assertion (precondition) entails the loop invariant. 
<div class="paragraph"> </div>

<a name="lab25"></a><h3 class="section">Proving separation-logic entailments</h3>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 14 (<i>PROP LOCAL SEP</i>)
     and Chapter 15 (<i>Entailments</i>) 
<div class="paragraph"> </div>

 This proof goal is an <i>entailment</i>,  <span class="inlinecode"><span class="id" type="var">ENTAIL</span></span> <span class="inlinecode"><span class="id" type="var">Delta</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">&#x22A2;-</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>,
   meaning "in context <span class="inlinecode"><span class="id" type="var">Delta</span></span>, any state that satisfies <span class="inlinecode"><span class="id" type="var">P</span></span> will
   also satisfy <span class="inlinecode"><span class="id" type="var">Q</span></span>."  

<div class="paragraph"> </div>

  In this case, the right-hand-side of this entailment is existentially
  quantified; it says: there exists a value <span class="inlinecode"><span class="id" type="var">i</span></span> such that (among
  other things) <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_i</span></span> <span class="inlinecode">(<span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">Int.repr</span></span> <span class="inlinecode"><span class="id" type="var">i</span>))</span>, that is, the C variable
  <span class="inlinecode"><span class="id" type="var">_i</span></span> contains the value <span class="inlinecode"><span class="id" type="var">i</span></span>.  But the left-hand-side of the
  entailment says <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_i</span></span> <span class="inlinecode">(<span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">Int.repr</span></span> <span class="inlinecode">0))</span>, that is, the C variable
  <span class="inlinecode"><span class="id" type="var">_i</span></span> contains 0.

<div class="paragraph"> </div>

  This is analogous to the following situation: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Set</span> <span class="id" type="var">Nested</span> <span class="id" type="var">Proofs</span> <span class="id" type="var">Allowed</span>.<br/>
<span class="id" type="keyword">Goal</span> <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">f</span>: <span class="id" type="var">Z</span>â†’<span class="id" type="var">Z</span>) (<span class="id" type="var">x</span>: <span class="id" type="var">Z</span>), <span class="id" type="var">f</span>(<span class="id" type="var">x</span>)=0 â†’ <span style='font-size:120%;'>&exist;</span><span class="id" type="var">i</span>:<span class="id" type="var">Z</span>, <span class="id" type="var">f</span>(<span class="id" type="var">x</span>)=<span class="id" type="var">i</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
To prove such a goal, one uses Coq's "exists" tactic to 
 demonstrate a value for <span class="inlinecode"><span class="id" type="var">i</span></span>: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span>0.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In a separation logic entailment, one can prove an <span class="inlinecode"><span class="id" type="var">EX</span></span> on the
  right-hand side by using the <span class="inlinecode"><span class="id" type="var">Exists</span></span> tactic to demonstrate a value
  for the quantified variable: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">Exists</span> 0. <span class="comment">(*&nbsp;Instantiate&nbsp;the&nbsp;existential&nbsp;on&nbsp;the&nbsp;right-side&nbsp;of&nbsp;&#x22A2;-&nbsp;&nbsp;&nbsp;*)</span><br/>
</div>

<div class="doc">
Notice that <span class="inlinecode"><span class="id" type="var">i</span></span> has now been replace with <span class="inlinecode">0</span> on the right side.

<div class="paragraph"> </div>

   To prove entailments, we usually use the <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> tactic to
   simplify the entailment as much as possible&mdash;or in many cases,
   to prove it entirely. 
</div>
<div class="code code-tight">

&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
In this case, it solves entirely; in other cases, entailer! 
    leaves subgoals for you to prove. 
<div class="paragraph"> </div>

<a name="lab26"></a><h3 class="section">Type-checking the loop test</h3>

</div>
<div class="code code-space">
* <span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
The second subgoal of <span class="inlinecode"><span class="id" type="var">forward_while</span></span> is always to prove that the 
  loop-test expression can evaluate without crashing&mdash;that is,
  all the variables it references exist and are initialized,
  it doesn't divide by zero, et cetera.

<div class="paragraph"> </div>

  We call this a "type-checking condition", the predicate <span class="inlinecode"><span class="id" type="var">tc_expr</span></span>.  
  In this case, it's the while-loop test <span class="inlinecode"><span class="id" type="var">i</span>&lt;<span class="id" type="var">n</span></span> that must execute,
  so we see <span class="inlinecode"><span class="id" type="var">tc_expr</span></span> <span class="inlinecode"><span class="id" type="var">Delta</span></span> <span class="inlinecode">(!</span> <span class="inlinecode">(<span class="id" type="var">_i</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">_n</span>))</span> on the right-hand side 
  of the entailment. 

<div class="paragraph"> </div>

  Very often, these <span class="inlinecode"><span class="id" type="var">tc_expr</span></span> goals solve automatically by <span class="inlinecode"><span class="id" type="var">entailer</span>!</span>. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
and indeed, this subgoal is solved. 
<div class="paragraph"> </div>

<a name="lab27"></a><h3 class="section">Proving that the loop body preserves the loop invariant</h3>

</div>
<div class="code code-space">
* <span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
The third subgoal of <span class="inlinecode"><span class="id" type="var">forward_while</span></span> is to prove
    that the loop body preserves the loop invariant.
   We must forward-symbolic-execute through the loop body. 
<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 16 (<i>Array subscripts</i>) 
<div class="paragraph"> </div>

 Examine the proof goal at the beginning of the loop body.  Above the
    line is the variable <span class="inlinecode"><span class="id" type="var">i</span></span>, introduced automatically by <span class="inlinecode"><span class="id" type="var">forward_while</span></span>
    from the existential <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">i</span>:<span class="id" type="var">Z</span></span> in the loop invariant.  

<div class="paragraph"> </div>

    The first C command in the loop body is the array subscript,
    <span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="var">_x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">a</span>[<span class="id" type="var">_i</span>];</span> <span class="inlinecode"></span>.   In order to prove this statement, the <span class="inlinecode"><span class="id" type="var">forward</span></span>
    tactic needs to be able to prove that <span class="inlinecode"><span class="id" type="var">i</span></span> is within bounds of the
    array.  When we try <span class="inlinecode"><span class="id" type="var">forward</span></span>, it fails:

</div>
<div class="code code-tight">

<span class="id" type="var">Fail</span> <span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;x&nbsp;=&nbsp;a<span class="inlinecode"><span class="id" type="var">i</span></span>&nbsp;*)</span><br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">forward</span></span> fails and tells us to first make <span class="inlinecode">0</span> <span class="inlinecode">â‰¤</span> <span class="inlinecode"><span class="id" type="var">i</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span>
   provable.  This auxiliary fact will help it prove that the array 
   subscript <span class="inlinecode"><span class="id" type="var">i</span></span> is within the bounds of the array <span class="inlinecode"><span class="id" type="var">a</span></span>.  It asks us to
   assert and prove some fact strong enough to imply this.

<div class="paragraph"> </div>

   Above the line we have <span class="inlinecode">0â‰¤<span class="id" type="var">i</span></span> and <span class="inlinecode"><span class="id" type="var">i</span>&lt;<span class="id" type="var">size</span></span>, so if we could prove
   <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">size</span></span> that would be enough.  Unfortunately,
   it won't work to do  <span class="inlinecode"><span class="id" type="tactic">assert</span></span> <span class="inlinecode">(<span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">size</span>)</span>  because
   there is not enough information above the line to prove that. 
<div class="paragraph"> </div>

 SEE ALSO: VST.pdf, Chapter "assert_PROP" 
<div class="paragraph"> </div>

 The required information to prove <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">size</span></span>
    comes from the <i>precondition</i> of the current <span class="inlinecode"><span class="id" type="var">semax</span></span> goal.  
    In the precondition, we have 
<pre>
   data_at sh (tarray tuint size) (map Vint (map Int.repr contents)) a
</pre>
   The <span class="inlinecode"><span class="id" type="var">data_at</span>}</span> <span class="inlinecode"><span class="id" type="var">predicate</span></span> <span class="inlinecode"><span class="id" type="var">always</span></span> <span class="inlinecode"><span class="id" type="var">enforces</span></span> <span class="inlinecode"><span class="id" type="var">that</span></span> <span class="inlinecode"><span class="id" type="var">the</span></span>  <span class="inlinecode">"<span class="id" type="var">contents</span>"</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="keyword">for</span></span>
   <span class="inlinecode"><span class="id" type="var">an</span></span> <span class="inlinecode"><span class="id" type="var">array</span></span> <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode"><span class="id" type="var">exactly</span></span> <span class="inlinecode"><span class="id" type="var">the</span></span> <span class="inlinecode"><span class="id" type="var">same</span></span> <span class="inlinecode"><span class="id" type="var">length</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">the</span></span> <span class="inlinecode"><span class="id" type="var">size</span></span> <span class="inlinecode"><span class="id" type="var">of</span></span> <span class="inlinecode"><span class="id" type="var">the</span></span> <span class="inlinecode"><span class="id" type="var">array</span>.</span>

   <span class="inlinecode"><span class="id" type="var">To</span></span> <span class="inlinecode"><span class="id" type="var">make</span></span> <span class="inlinecode"><span class="id" type="var">use</span></span> <span class="inlinecode"><span class="id" type="var">of</span></span> <span class="inlinecode"><span class="id" type="var">precondition</span></span> <span class="inlinecode"><span class="id" type="var">facts</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode"><span class="id" type="var">an</span></span> <span class="inlinecode"><span class="id" type="var">assertion</span>,</span> <span class="inlinecode"><span class="id" type="var">use</span></span> <span class="inlinecode">[<span class="id" type="var">assert_PROP</span>].</span> <span class="inlinecode"></span>
</div>
<div class="code code-tight">

<span class="id" type="var">assert_PROP</span> (<span class="id" type="var">Zlength</span> <span class="id" type="var">contents</span> = <span class="id" type="var">size</span>). {<br/>
<br/>
<span class="comment">(**&nbsp;The&nbsp;proof&nbsp;goal&nbsp;is&nbsp;an&nbsp;entailment,&nbsp;with&nbsp;the&nbsp;current&nbsp;precondition&nbsp;on<br/>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;left,&nbsp;and&nbsp;the&nbsp;proposition&nbsp;to&nbsp;be&nbsp;proved&nbsp;on&nbsp;the&nbsp;right.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;As&nbsp;usual,&nbsp;to&nbsp;prove&nbsp;an&nbsp;entailment,&nbsp;we&nbsp;use&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">entailer</span>!</span>&nbsp;tactic<br/>
&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;simplify&nbsp;the&nbsp;proof&nbsp;goal:&nbsp;*)</span><br/>
<br/>
&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Indeed, <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> has done almost all the work.  If you want
   to see how <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> did it, undo the last step and use these 
   two tactics:  <span class="inlinecode"><span class="id" type="var">go_lower</span>.</span>  <span class="inlinecode"><span class="id" type="var">saturate_local</span>.</span>
   The job of <span class="inlinecode"><span class="id" type="var">go_lower</span></span> is to process the PROP and LOCAL parts of 
   the entailment; and <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> derives all the propositional
   facts derivable from the <span class="inlinecode"><span class="id" type="var">mpred</span></span>s on the left-hand-side, and puts
   those facts above the line.  In this case, above the line is,
   <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode">(<span class="id" type="var">unfold_reptype</span></span> <span class="inlinecode">(<span class="id" type="var">map</span></span> <span class="inlinecode"><span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">map</span></span> <span class="inlinecode"><span class="id" type="var">Int.repr</span></span> <span class="inlinecode"><span class="id" type="var">contents</span>)))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">size</span></span>
   which is the fact we need. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">hint</span></span> suggests that <span class="inlinecode"><span class="id" type="var">list_solve</span></span> solves this goal,
   <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode">(<span class="id" type="var">map</span></span> <span class="inlinecode"><span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">map</span></span> <span class="inlinecode"><span class="id" type="var">Int.repr</span></span> <span class="inlinecode"><span class="id" type="var">contents</span>))</span>.
   Indeed, <span class="inlinecode"><span class="id" type="var">list_solve</span></span> knows a lot of things about the interaction
   of list operators: <span class="inlinecode"><span class="id" type="var">Zlength</span>,</span> <span class="inlinecode"><span class="id" type="var">map</span>,</span> <span class="inlinecode"><span class="id" type="var">sublist</span>,</span> etc.

<div class="paragraph"> </div>

   Or, we can solve the goal "by hand": 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Zlength_map</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
} <br/>
<span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
Now that we have <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">size</span></span> above the, we can go
   <span class="inlinecode"><span class="id" type="var">forward</span></span> through the array-subscript statement. 
</div>
<div class="code code-tight">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">a</span>[<span class="id" type="var">i</span>];</span>&nbsp;*)</span><br/>
</div>

<div class="doc">
Now <span class="inlinecode"><span class="id" type="var">forward</span></span> through the rest of the loop body. 
</div>
<div class="code code-tight">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;s&nbsp;+=&nbsp;x;&nbsp;*)</span><br/>
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;i++;&nbsp;*)</span><br/>
</div>

<div class="doc">
SEE ALSO: VC.pdf Chapter 17 (<i>At the end of the loop body</i>) 
<div class="paragraph"> </div>

 We have reached the end of the loop body, and it's
   time to prove that the <i>current precondition</i>  (which is the
   postcondition of the loop body) entails the loop invariant. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="var">Exists</span> (<span class="id" type="var">i</span>+1).<br/>
&nbsp;<span class="id" type="var">entailer</span>!.<br/>
&nbsp;<span class="id" type="tactic">f_equal</span>. <span class="id" type="tactic">f_equal</span>.<br/>
</div>

<div class="doc">
Here the proof goal is,
<pre>
   sum_Z (sublist 0 (i + 1) contents) =
   sum_Z (sublist 0 i contents) + Znth i contents
</pre>
   We will prove this in stages:
<pre>
   sum_Z (sublist 0 (i + 1) contents) =
   sum_Z (sublist 0 i contents ++ sublist i (i+1) contents) =
   sum_Z (sublist 0 i contents) + sum_Z (sublist i (i+1) contents) =
   sum_Z (sublist 0 i contents) + sum_Z (Znth i contents :: nil) =
   sum_Z (sublist 0 i contents) + Znth i contents
</pre>
 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">sublist_split</span> 0 <span class="id" type="var">i</span> (<span class="id" type="var">i</span>+1)) <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">sum_Z_app</span>. <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">sublist_one</span> <span class="id" type="var">i</span>) <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">omega</span>.<br/>
</div>

<div class="doc">
After the loop, our precondition is the conjuction of the loop 
    invariant and the negation of the loop test.  
<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 18 (<i>Returning from a function</i>) 
</div>
<div class="code code-tight">

* <span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
You can always go <span class="inlinecode"><span class="id" type="var">forward</span></span> through a <span class="inlinecode"><span class="id" type="keyword">return</span></span> statement.
  The resulting proof goal is an entailment, that the current
  precondition implies the function's postcondition. 
</div>
<div class="code code-tight">

<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;return&nbsp;s;&nbsp;*)</span><br/>
</div>

<div class="doc">
Here we prove that the postcondition of the function body
    entails the postcondition demanded by the function specification. 
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="var">hint</span>.<br/>
<span class="id" type="var">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">sublist</span> <span class="id" type="keyword">in</span> *&#x22A2;.<br/>
<span class="id" type="var">hint</span>.<br/>
<span class="id" type="var">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">sublist</span>.<br/>
<span class="id" type="var">hint</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab28"></a><h2 class="section">Global variables and main()</h2>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 19 (<i>Global variables and main</i>) 
</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;Contents&nbsp;of&nbsp;the&nbsp;extern&nbsp;global&nbsp;initialized&nbsp;array&nbsp;"_four"&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">four_contents</span> := [1; 2; 3; 4].<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_main</span>:  <span class="id" type="var">semax_body</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span> <span class="id" type="var">f_main</span> <span class="id" type="var">main_spec</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">start_function</span>.<br/>
</div>

<div class="doc">
C programs may have extern global variables, either with
  explicit initializers or implicitly initialized to zero.
  Because they live in memory, they need to be described by a
  separation logic predicate, a "resource" that gets passed from
  one function to another via the SEP part of funspec preconditions
  and postconditions.  Initially, all the global-variable resources
  are passed into the <span class="inlinecode"><span class="id" type="var">main</span></span> function, as its precondition.  The
  built-in operator <span class="inlinecode"><span class="id" type="var">main_pre</span></span> calculates this precondition of <span class="inlinecode"><span class="id" type="var">main</span></span>
  by examining all the global declarations of the program.

<div class="paragraph"> </div>

  In this program, there is one global variable,
<pre>
    unsigned four[4] = {1,2,3,4};
</pre>
  and we can see its SEP assertion in the precondition of the
  current proof goal:
<pre>
   data_at Ews (tarray tuint 4)
           (map Vint [Int.repr 1; Int.repr 2; Int.repr 3; Int.repr 4])
           (gv _four)
</pre>
 
<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 20 (<i>Function calls</i>) 
<div class="paragraph"> </div>

 We are ready to prove the function-call, <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">sumarray</span>(<span class="id" type="var">four</span>,4);</span>
   We use the <span class="inlinecode"><span class="id" type="var">forward_call</span></span> tactic, and for the argument we must supply
   a tuple of values that instantiates the WITH clause of the called
   function's funspec.  In <span class="inlinecode"><span class="id" type="var">DECLARE</span></span> <span class="inlinecode"><span class="id" type="var">_sumarray</span></span>, the <span class="inlinecode"><span class="id" type="var">WITH</span></span> clause reads,
   <span class="inlinecode"><span class="id" type="var">WITH</span></span> <span class="inlinecode"><span class="id" type="var">a</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span>,</span> <span class="inlinecode"><span class="id" type="var">sh</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">share</span>,</span> <span class="inlinecode"><span class="id" type="var">contents</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Z</span>,</span> <span class="inlinecode"><span class="id" type="var">size</span>:</span> <span class="inlinecode"><span class="id" type="var">Z</span></span>.
   Therefore the argument to <span class="inlinecode"><span class="id" type="var">forward_call</span></span> must be a four-tuple of type,
   <span class="inlinecode">(<span class="id" type="var">val</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">share</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Z</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">Z</span>)</span>.  
</div>
<div class="code code-tight">
<span class="id" type="var">forward_call</span> <span class="comment">(*&nbsp;&nbsp;s&nbsp;=&nbsp;sumarray(four,4);&nbsp;*)</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">gv</span> <span class="id" type="var">_four</span>, <span class="id" type="var">Ews</span>, <span class="id" type="var">four_contents</span>, 4).<br/>
</div>

<div class="doc">
The subgoal of <span class="inlinecode"><span class="id" type="var">forward_call</span></span> is that we have to prove the PROP
  part of the <span class="inlinecode"><span class="id" type="var">sumarray</span></span> function's precondition. 
</div>
<div class="code code-tight">

&nbsp;<span class="id" type="var">split3</span>. <span class="id" type="tactic">auto</span>. <span class="id" type="var">computable</span>. <span class="id" type="tactic">repeat</span> <span class="id" type="var">constructor</span>; <span class="id" type="var">computable</span>.<br/>
</div>

<div class="doc">
Now we are after the function-call, and we can go forward through
  the return statement. 
</div>
<div class="code code-tight">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;return&nbsp;s;&nbsp;*)</span><br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab29"></a><h2 class="section">Tying all the functions together</h2>

<div class="paragraph"> </div>

 SEE ALSO: VC.pdf Chapter 21 (<i>Tying all the functions together</i>) 
<div class="paragraph"> </div>

 The C program may do input/output, affecting the state of the
  outside world.  This state is described (abstractly) by the <span class="inlinecode"><span class="id" type="var">Espec</span></span>,
  the "external specification."  The sumarray program does not do
  any input/output, so we can use a trivial <span class="inlinecode"><span class="id" type="var">Espec</span></span>.  We provide
  this to the <span class="inlinecode"><span class="id" type="var">semax_prog</span></span> proofs (below, in the <span class="inlinecode"><span class="id" type="var">prog_correct</span></span> lemma)
  via a typeclass instance, as follows: 
</div>
<div class="code code-tight">

<span class="id" type="var">Existing</span> <span class="id" type="keyword">Instance</span> <span class="id" type="var">NullExtension.Espec</span>.<br/>
</div>

<div class="doc">
Now, an entire C program is proved correct if all the functions
  satisfy their funspecs.  We listed all those functions (upon whose
  specifications we depend) in the <span class="inlinecode"><span class="id" type="var">Gprog</span></span> definition.  The judgment
  <span class="inlinecode"><span class="id" type="var">semax_prog</span></span> <span class="inlinecode"><span class="id" type="var">prog</span></span> <span class="inlinecode"><span class="id" type="var">Vprog</span></span> <span class="inlinecode"><span class="id" type="var">Gprog</span></span> says, "In the program <span class="inlinecode"><span class="id" type="var">prog</span></span>, whose
  <span class="inlinecode"><span class="id" type="var">varspecs</span></span> are <span class="inlinecode"><span class="id" type="var">Vprog</span></span> and whose funspecs are <span class="inlinecode"><span class="id" type="var">Gprog</span></span>, every 
  function mentioned in <span class="inlinecode"><span class="id" type="var">Gprog</span></span> does satisfy its specification." 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">prog_correct</span>: <span class="id" type="var">semax_prog</span> <span class="id" type="var">prog</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">prove_semax_prog</span>.<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">semax_func</span></span> proof goal here has a list of function bodies,
<pre>
    [(_sumarray, Internal f_sumarray); (_main, Internal f_main)]
</pre>
   and corresponding list of funspecs,
<pre>
    [(_sumarray, spec-of-sumarray); (_main, spec-of-main)].
</pre>
  Each call to the <span class="inlinecode"><span class="id" type="var">semax_func_cons</span></span> tactic uses a (previously proved)
  <span class="inlinecode"><span class="id" type="var">semax_body</span></span> theorem to match up a function body to its funspec.

</div>
<div class="code code-tight">

<span class="id" type="var">semax_func_cons</span> <span class="id" type="var">body_sumarray</span>.<br/>
<span class="id" type="var">semax_func_cons</span> <span class="id" type="var">body_main</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab30"></a><h2 class="section">Additional recommended reading</h2>

<div class="paragraph"> </div>

 Recommended: read VC.pdf Chapters 22-45, (up to <i>Pointer comparisons</i>) 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;Wed&nbsp;Apr&nbsp;24&nbsp;08:45:36&nbsp;EDT&nbsp;2019&nbsp;*)</span><br/>
</div>
</div>



</div>

</body>
</html>