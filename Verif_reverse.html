<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Verif_reverse: Linked lists in Verifiable C</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/vc.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 5beta: Verifiable C</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>Table of Contents</li></a>
   <a href='coqindex.html'><li class='section_name'>Index</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">Verif_reverse<span class="subtitle">Linked lists in Verifiable C</span></h1>


<div class="doc">

<div class="paragraph"> </div>

<a name="lab31"></a><h2 class="section">Here is a little C program, <span class="inlinecode"><span class="id" type="var">reverse.c</span></span></h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<pre>
#include &lt;stddef.h&gt;

struct list {unsigned head; struct list *tail;};

struct list *reverse (struct list *p) {
  struct list *w, *t, *v;
  w = NULL;
  v = p;
  while (v) {
    t = v<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>tail;
    v<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>tail = w;
    w = v;
    v = t;
  }
  return w;
}
</pre>
 
<div class="paragraph"> </div>

 SEE ALSO VC.pdf Chapter 46 (<i>Proof of the reverse program</i>) 
<div class="paragraph"> </div>

 As usual, we import the Verifiable C system <span class="inlinecode"><span class="id" type="var">VST.floyd.proofauto</span></span>,
  then the program to be verified, in this case <span class="inlinecode"><span class="id" type="var">reverse</span></span>.  Then we give
  the standard boilerplate definitions of <span class="inlinecode"><span class="id" type="var">CompSpecs</span></span> and <span class="inlinecode"><span class="id" type="var">Vprog</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">VST.floyd.proofauto</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">VC.reverse</span>.<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">CompSpecs</span> : <span class="id" type="var">compspecs</span>. <span class="id" type="var">make_compspecs</span> <span class="id" type="var">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Vprog</span> : <span class="id" type="var">varspecs</span>. <span class="id" type="var">mk_varspecs</span> <span class="id" type="var">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
</div>

<div class="doc">
<a name="lab32"></a><h2 class="section">Inductive definition of linked lists</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">Tstruct</span></span> <span class="inlinecode"><span class="id" type="var">_list</span></span> <span class="inlinecode"><span class="id" type="var">noattr</span></span> is the AST (abstract syntax tree) description
 of the C-language type <span class="inlinecode"><span class="id" type="keyword">struct</span></span> <span class="inlinecode"><span class="id" type="var">list</span></span>.  We will be using this a lot,
 so we make an abbreviation for it, t_list: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">t_list</span> := <span class="id" type="var">Tstruct</span> <span class="id" type="var">_list</span> <span class="id" type="var">noattr</span>.<br/>
</div>

<div class="doc">
We will define a separation-logic predicate, <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>,
 to describe the concept that the address <span class="inlinecode"><span class="id" type="var">p</span></span> in memory is a linked
 list that represents the mathematical sequence <span class="inlinecode"><span class="id" type="var">sigma</span></span>.  
 Here, <span class="inlinecode"><span class="id" type="var">sigma</span></span> is a list of <span class="inlinecode"><span class="id" type="var">val</span></span>,  which is C's "value" type: 
 integers, pointers, floats, etc. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">listrep</span> (<span class="id" type="var">sigma</span>: <span class="id" type="var">list</span> <span class="id" type="var">val</span>) (<span class="id" type="var">p</span>: <span class="id" type="var">val</span>) : <span class="id" type="var">mpred</span> :=<br/>
&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;| <span class="id" type="var">h</span>::<span class="id" type="var">hs</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">EX</span> <span class="id" type="var">y</span>:<span class="id" type="var">val</span>, <span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">h</span>,<span class="id" type="var">y</span>) <span class="id" type="var">p</span>  *  <span class="id" type="var">listrep</span> <span class="id" type="var">hs</span> <span class="id" type="var">y</span><br/>
&nbsp;| <span class="id" type="var">nil</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;!! (<span class="id" type="var">p</span> = <span class="id" type="var">nullval</span>) &amp;&amp; <span class="id" type="var">emp</span><br/>
&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
This says, if <span class="inlinecode"><span class="id" type="var">sigma</span></span> has head <span class="inlinecode"><span class="id" type="var">h</span></span> and tail <span class="inlinecode"><span class="id" type="var">hs</span></span>, then
  there is a cons cell at address <span class="inlinecode"><span class="id" type="var">p</span></span> with components <span class="inlinecode">(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)</span>.
  This cons cell is described by <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span>.
  Separate from that, at address <span class="inlinecode"><span class="id" type="var">y</span></span>, there is the representation
  of the rest of the list, <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">hs</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span>.  The memory footprint
  for <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>::<span class="id" type="var">hs</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span> contains the first cons cell at address <span class="inlinecode"><span class="id" type="var">p</span></span>,
  and the rest of the cons cells in the list starting at address <span class="inlinecode"><span class="id" type="var">y</span></span>.

<div class="paragraph"> </div>

  But if <span class="inlinecode"><span class="id" type="var">sigma</span></span> is <span class="inlinecode"><span class="id" type="var">nil</span></span>, then <span class="inlinecode"><span class="id" type="var">p</span></span> is the null pointer, and the
  memory footprint is empty (<span class="inlinecode"><span class="id" type="var">emp</span></span>).  The fact <span class="inlinecode"><span class="id" type="var">p</span>=<span class="id" type="var">nullval</span></span> is a pure
  proposition (Coq <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>); we inject this into the assertion language
  (Coq <span class="inlinecode"><span class="id" type="var">mpred</span></span>) using the <span class="inlinecode">!!</span> operator.

<div class="paragraph"> </div>

  Because <span class="inlinecode">!!<span class="id" type="var">P</span></span> (for a proposition <span class="inlinecode"><span class="id" type="var">P</span></span>) does not specify any footprint
  (whether empty or otherwise), we do not use the separating conjunction
  <span class="inlinecode">*</span> to combine it with <span class="inlinecode"><span class="id" type="var">emp</span></span>;  <span class="inlinecode">!!<span class="id" type="var">P</span></span> has no <i>spatial</i> specification
  to separate from.  Instead, we use the ordinary conjunction <span class="inlinecode">&amp;&amp;</span>.

<div class="paragraph"> </div>

 Now, we want to prevent the <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> tactic from automatically
 unfolding <span class="inlinecode"><span class="id" type="var">listrep</span></span>.  This is a design choice that you might make
 differently, in which case, leave out the <span class="inlinecode"><span class="id" type="var">Arguments</span></span> command. 
</div>
<div class="code code-tight">

<span class="id" type="var">Arguments</span> <span class="id" type="var">listrep</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span> : <span class="id" type="tactic">simpl</span> <span class="id" type="var">never</span>.<br/>
</div>

<div class="doc">
<a name="lab33"></a><h2 class="section">Hint databases for spatial operators</h2>

<div class="paragraph"> </div>

 Whenever you define a new spatial operator&mdash;a definition of type
  <span class="inlinecode"><span class="id" type="var">mpred</span></span> such as <span class="inlinecode"><span class="id" type="var">listrep</span></span>&mdash;it's useful to populate two hint  databases.

<div class="paragraph"> </div>

<ul class="doclist">
<li> The <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> hint is a lemma that extracts
     pure propositional facts from a spatial fact.

</li>
<li> The <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> hint is a lemma that extracts a
     valid-pointer fact from a spatial lemma.

</li>
</ul>
 
<div class="paragraph"> </div>

 Consider this proof goal: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">data_at_isptr_example1</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">h</span> <span class="id" type="var">y</span> <span class="id" type="var">p</span> : <span class="id" type="var">val</span>) ,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">h</span>,<span class="id" type="var">y</span>) <span class="id" type="var">p</span> &#x22A2;- !! <span class="id" type="var">isptr</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> means <span class="inlinecode"><span class="id" type="var">p</span></span> is a non-null pointer, not NULL or Vundef or a floating-point number: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">isptr</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;fun&nbsp;v&nbsp;:&nbsp;val&nbsp;=&gt;&nbsp;match&nbsp;v&nbsp;with&nbsp;Vptr&nbsp;_&nbsp;_&nbsp;=&gt;&nbsp;True&nbsp;|&nbsp;_&nbsp;=&gt;&nbsp;False&nbsp;end&nbsp;*)</span><br/>
</div>

<div class="doc">
The goal solves automatically, using <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> 
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">data_at_isptr_example2</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">h</span> <span class="id" type="var">y</span> <span class="id" type="var">p</span> : <span class="id" type="var">val</span>) ,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">h</span>,<span class="id" type="var">y</span>) <span class="id" type="var">p</span> &#x22A2;- !! <span class="id" type="var">isptr</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
Let's look more closely at how <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> solves this goal.  
     First, it finds all the pure propositions <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> that it can deduce from  the
     <span class="inlinecode"><span class="id" type="var">mpred</span></span> conjuncts on the left-hand side, and puts them above the line. 
</div>
<div class="code code-tight">
<span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> tactic uses a Hint database (also called <span class="inlinecode"><span class="id" type="var">saturate_local</span></span>)
   to look up the individual conjuncts on the left-hand side (this particular entailment
   has just one conjunct). 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">HintDb</span> <span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
In this case, the new propositions above the line are labeled <span class="inlinecode"><span class="id" type="var">H</span></span> and <span class="inlinecode"><span class="id" type="var">H<sub>0</sub></span></span>.  Next, if the proof goal has just a proposition <span class="inlinecode">!!<span class="id" type="var">P</span></span> on the right,
    <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> throws away the left-hand-side and tries to prove <span class="inlinecode"><span class="id" type="var">P</span></span>.
    (This is rather aggressive, and can sometimes lose information, that is,
     sometimes <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> will turn a provable goal into an unprovable goal.)

</div>
<div class="code code-tight">
<span class="id" type="tactic">apply</span> <span class="id" type="var">prop_right</span>.<br/>
</div>

<div class="doc">
It happens that <span class="inlinecode"><span class="id" type="var">field_compatible</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> implies <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">field_compatible_isptr</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;:&nbsp;forall&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(path&nbsp;:&nbsp;list&nbsp;gfield)&nbsp;(p&nbsp;:&nbsp;val),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field_compatible&nbsp;t&nbsp;path&nbsp;p&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;isptr&nbsp;p&nbsp;*)</span><br/>
</div>

<div class="doc">
So therefore, <span class="inlinecode"><span class="id" type="var">field_compatible_isptr</span></span> solves the goal. 
</div>
<div class="code code-tight">
<span class="id" type="tactic">eapply</span> <span class="id" type="var">field_compatible_isptr</span>; <span class="id" type="tactic">eauto</span>.<br/>
<span class="comment">(*&nbsp;Now&nbsp;you&nbsp;have&nbsp;some&nbsp;insight&nbsp;into&nbsp;how&nbsp;<span class="inlinecode"><span class="id" type="var">entailer</span>!</span>&nbsp;works.&nbsp;*)</span><br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
But when you define a new spatial predicate <span class="inlinecode"><span class="id" type="var">mpred</span></span> such as <span class="inlinecode"><span class="id" type="var">listrep</span></span>,
   the <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> tactic does not know how to deduce <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> facts
   from the <span class="inlinecode"><span class="id" type="var">listrep</span></span> conjunct: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">listrep_facts_example</span>:<br/>
&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span> &#x22A2;- !! (<span class="id" type="var">isptr</span> <span class="id" type="var">p</span> ∨ <span class="id" type="var">p</span>=<span class="id" type="var">nullval</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Here, <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> threw away the left-hand-side and left an unprovable goal.
   Let's see why. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">listrep_facts_example</span>:<br/>
&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span> &#x22A2;- !! (<span class="id" type="var">isptr</span> <span class="id" type="var">p</span> ∨ <span class="id" type="var">p</span>=<span class="id" type="var">nullval</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
First <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> would use <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> to see (from the Hint database)
   what can be deduced from <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
But <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> did not add anything above the line.  That's because
   there's no Hint in the Hint database for <span class="inlinecode"><span class="id" type="var">listrep</span></span>.  
   Therefore we must add one.   The conventional name for such a lemma
   is  <span class="inlinecode"><span class="id" type="var">f_local_facts</span></span>, if your new predicate is named <span class="inlinecode"><span class="id" type="var">f</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">listrep_local_facts</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span> &#x22A2;-<br/>
&nbsp;&nbsp;&nbsp;!! (<span class="id" type="var">is_pointer_or_null</span> <span class="id" type="var">p</span> ∧ (<span class="id" type="var">p</span>=<span class="id" type="var">nullval</span> ↔ <span class="id" type="var">sigma</span>=<span class="id" type="var">nil</span>)).<br/>
</div>

<div class="doc">
For each spatial predicate <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">f</span>(<span class="id" type="var">_</span>):</span> <span class="inlinecode"><span class="id" type="var">mpred</span></span>,
  there should be <i>one</i> "local fact", a lemma of the form
  <span class="inlinecode"><span class="id" type="var">f</span>(<span class="id" type="var">_</span>)</span> <span class="inlinecode">&#x22A2;-</span> <span class="inlinecode">!!</span> <span class="inlinecode"><span class="id" type="var">_</span></span>.  On the right hand side, put all the propositions
  you can derive from <span class="inlinecode"><span class="id" type="var">f</span>(<span class="id" type="var">_</span>)</span>.  In this case, we know:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">p</span></span> is either a pointer or null (it's never <span class="inlinecode"><span class="id" type="var">Vundef</span></span>, or <span class="inlinecode"><span class="id" type="var">Vfloat</span></span>, or a nonzero <span class="inlinecode"><span class="id" type="var">Vint</span></span>).

</li>
<li> <span class="inlinecode"><span class="id" type="var">p</span></span> is null, if and only if <span class="inlinecode"><span class="id" type="var">sigma</span></span> is nil.

</li>
</ul>

</div>
<div class="code code-tight">
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
We will prove this entailment by induction on sigma 
</div>
<div class="code code-tight">
<span class="id" type="var">revert</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">p</span>.<br/>
- <span class="comment">(**&nbsp;In&nbsp;the&nbsp;base&nbsp;case,&nbsp;<span class="inlinecode"><span class="id" type="var">sigma</span></span>&nbsp;is&nbsp;nil.&nbsp;&nbsp;We&nbsp;can&nbsp;unfold&nbsp;the&nbsp;definition<br/>
&nbsp;&nbsp;&nbsp;of&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span>&nbsp;to&nbsp;see&nbsp;what&nbsp;that&nbsp;means.&nbsp;*)</span><br/>
&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span>.<br/>
</div>

<div class="doc">
Now we have an entailment with a proposition <span class="inlinecode"><span class="id" type="var">p</span>=<span class="id" type="var">nullval</span></span> on the left.
 To move that proposition above the line, we could do <span class="inlinecode"><span class="id" type="var">Intros</span></span>, but
 it's easier just to call on <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> to see how it can simplify (and perhaps
 partially solve) this entailment goal: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
&nbsp;<span class="comment">(*&nbsp;The&nbsp;<span class="inlinecode"><span class="id" type="var">entailer</span>!</span>&nbsp;has&nbsp;left&nbsp;an&nbsp;ordinary&nbsp;proposition,&nbsp;which&nbsp;is&nbsp;easy&nbsp;to&nbsp;solve.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">auto</span>.<br/>
- <span class="comment">(**&nbsp;In&nbsp;the&nbsp;inductive&nbsp;case,&nbsp;we&nbsp;can&nbsp;again&nbsp;unfold&nbsp;the&nbsp;definition<br/>
&nbsp;&nbsp;&nbsp;of&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode">(<span class="id" type="var">a</span>::<span class="id" type="var">sigma</span>)</span>;&nbsp;but&nbsp;then&nbsp;it's&nbsp;good&nbsp;to&nbsp;fold&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span>.<br/>
&nbsp;&nbsp;&nbsp;Replace&nbsp;the&nbsp;semicolon&nbsp;<span class="inlinecode">;</span>&nbsp;with&nbsp;a&nbsp;period&nbsp;in&nbsp;the&nbsp;next&nbsp;line,&nbsp;to&nbsp;see&nbsp;why.&nbsp;*)</span><br/>
&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span>; <span class="id" type="var">fold</span> <span class="id" type="var">listrep</span>.<br/>
</div>

<div class="doc">
Warning!  Sometimes <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> is too aggressive.  If we use it
  here, it will throw away the left-hand side because it doesn't
  understand how to look inside an EXistential quantitier.  The
  exclamation point <span class="inlinecode">!</span> is a warning that <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> can turn a
  provable goal into an unprovable goal.  Uncomment the next line
  and see what happens.  Then put the comment marks back. 
</div>
<div class="code code-tight">
&nbsp;<span class="comment">(*&nbsp;entailer!.&nbsp;*)</span><br/>
</div>

<div class="doc">
The preferred way to handle <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">y</span>:<span class="id" type="var">t</span></span> on the left-hand-side of an
 entailment is to use <span class="inlinecode"><span class="id" type="var">Intros</span></span> <span class="inlinecode"><span class="id" type="var">y</span>.</span>  Uncomment this to try it out, then
 put the comment marks back. 
</div>
<div class="code code-tight">
&nbsp;<span class="comment">(*&nbsp;Intros&nbsp;y.&nbsp;*)</span><br/>
</div>

<div class="doc">
A less agressive entailment-reducer is <span class="inlinecode"><span class="id" type="var">entailer</span></span> without the
    exclamation point. This one never turns a provable goal into an
    unprovable goal.  Here it will Intro the EX-bound variable y. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="var">entailer</span>.<br/>
</div>

<div class="doc">
Should you use <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> or <span class="inlinecode"><span class="id" type="var">entailer</span></span> in ordinary proofs?
  Usually <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> is best: it's faster, and it does more work for you.
  Only if you  find that <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> has gone into a dead end, should
  you use <span class="inlinecode"><span class="id" type="var">entailer</span></span> instead. 
<div class="paragraph"> </div>

 Here it is safe to use <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Notice that entailer! has put several facts above the line:
  <span class="inlinecode"><span class="id" type="var">field_compatible</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">[]</span> <span class="inlinecode"><span class="id" type="var">p</span></span> and <span class="inlinecode"><span class="id" type="var">value_fits</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">a</span>,<span class="id" type="var">y</span>)</span> come from the 
  <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> hint database, from the <span class="inlinecode"><span class="id" type="var">data_at</span></span> conjunct;  and 
  <span class="inlinecode"><span class="id" type="var">is_pointer_or_null</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> and <span class="inlinecode"><span class="id" type="var">y</span>=<span class="id" type="var">nullval</span></span> <span class="inlinecode">↔</span> <span class="inlinecode"><span class="id" type="var">sigma</span>=[]</span> come from the
  the <span class="inlinecode"><span class="id" type="var">listrep</span></span> conjunct, using the induction hypothesis <span class="inlinecode"><span class="id" type="var">IHsigma</span></span>.

<div class="paragraph"> </div>

  Now, let's split the goal and take the two cases separately. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span>.<br/>
&nbsp;&nbsp;*<br/>
&nbsp;<span class="id" type="tactic">clear</span> - <span class="id" type="var">H</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
&nbsp;<span class="id" type="tactic">subst</span> <span class="id" type="var">p</span>.<br/>
</div>

<div class="doc">
It happens that <span class="inlinecode"><span class="id" type="var">field_compatible</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> implies <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">field_compatible_isptr</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;:&nbsp;forall&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(path&nbsp;:&nbsp;list&nbsp;gfield)&nbsp;(p&nbsp;:&nbsp;val),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field_compatible&nbsp;t&nbsp;path&nbsp;p&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;isptr&nbsp;p&nbsp;*)</span><br/>
</div>

<div class="doc">
 The predicate isptr excludes the null pointer, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">isptr</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;fun&nbsp;v&nbsp;:&nbsp;val&nbsp;=&gt;&nbsp;match&nbsp;v&nbsp;with&nbsp;Vptr&nbsp;_&nbsp;_&nbsp;=&gt;&nbsp;True&nbsp;|&nbsp;_&nbsp;=&gt;&nbsp;False&nbsp;end&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">nullval</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;if&nbsp;Archi.ptr64&nbsp;then&nbsp;Vlong&nbsp;Int64.zero&nbsp;else&nbsp;Vint&nbsp;Int.zero&nbsp;*)</span><br/>
</div>

<div class="doc">
Therefore <span class="inlinecode"><span class="id" type="var">H</span></span> is a contradiction.  We can proceed with, 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Check</span> <span class="id" type="var">field_compatible_nullval</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;=&nbsp;forall&nbsp;(CS&nbsp;:&nbsp;compspecs)&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(f&nbsp;:&nbsp;list&nbsp;gfield)&nbsp;(P&nbsp;:&nbsp;Type),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field_compatible&nbsp;t&nbsp;f&nbsp;nullval&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;P&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <span class="id" type="var">field_compatible_nullval</span>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;* <span class="comment">(*The&nbsp;case&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">sigma</span>=[]</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">p</span>=<span class="id" type="var">nullval</span></span>&nbsp;is&nbsp;easy,&nbsp;by&nbsp;inversion:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now we add this lemma to the Hint database called <span class="inlinecode"><span class="id" type="var">saturate_local</span></span> 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Hint</span> <span class="id" type="keyword">Resolve</span> <span class="id" type="var">listrep_local_facts</span> : <span class="id" type="var">saturate_local</span>.<br/>
</div>

<div class="doc">
<a name="lab34"></a><h3 class="section">Valid pointers, and the <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> Hint database</h3>

<div class="paragraph"> </div>

 In the C language, you can do a pointer comparison such as <span class="inlinecode"><span class="id" type="var">p</span>!=<span class="id" type="var">NULL</span></span> or
    <span class="inlinecode"><span class="id" type="var">p</span>==<span class="id" type="var">q</span></span> only if <span class="inlinecode"><span class="id" type="var">p</span></span> is a <i>valid pointer</i>, that is, either NULL or actually 
    pointing within an allocated object.  One way to prove that <span class="inlinecode"><span class="id" type="var">p</span></span> is
    valid is if, for example,   <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span>, meaning that <span class="inlinecode"><span class="id" type="var">p</span></span>
    is pointing at a list cell.  There is a hint database <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> from
    which the predicate <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> can be proved automatically.
    For example: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">struct_list_valid_pointer_example</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">h</span> <span class="id" type="var">y</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">h</span>,<span class="id" type="var">y</span>) <span class="id" type="var">p</span> &#x22A2;- <span class="id" type="var">valid_pointer</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">valid_pointer</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
However, the hint database does not know about user-defined 
    separation-logic predicates (<span class="inlinecode"><span class="id" type="var">mpred</span></span>) such as <span class="inlinecode"><span class="id" type="var">listrep</span></span>; for example: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">listrep_valid_pointer_example</span>:<br/>
&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">sigma</span> <span class="id" type="var">p</span>, <br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span> &#x22A2;- <span class="id" type="var">valid_pointer</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">valid_pointer</span>.<br/>
</div>

<div class="doc">
Notice that <span class="inlinecode"><span class="id" type="tactic">auto</span></span> <span class="inlinecode"><span class="id" type="keyword">with</span>...</span> did not solve the proof goal 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
Therefore, we should prove the appropriate lemma, and add it to the
   Hint database.  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">listrep_valid_pointer</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">sigma</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span> &#x22A2;- <span class="id" type="var">valid_pointer</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
The main point is to unfold listrep. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span>.<br/>
</div>

<div class="doc">
Now we can prove it by case analysis on sigma; we don't even need
   induction. 
</div>
<div class="code code-tight">
&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">simpl</span>.<br/>
* <span class="comment">(**&nbsp;The&nbsp;&nbsp;nil&nbsp;case&nbsp;is&nbsp;easy:&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">hint</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(**&nbsp;&nbsp;The&nbsp;cons&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">Intros</span> <span class="id" type="var">y</span>.<br/>
</div>

<div class="doc">
Now this solves using the Hint database <span class="inlinecode"><span class="id" type="var">valid_pointer</span></span>, because the
     <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">v</span>,<span class="id" type="var">y</span>)</span> <span class="inlinecode"><span class="id" type="var">p</span></span> on the left is enough to prove the goal. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">valid_pointer</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now we add this lemma to the Hint database 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Hint</span> <span class="id" type="keyword">Resolve</span> <span class="id" type="var">listrep_valid_pointer</span> : <span class="id" type="var">valid_pointer</span>.<br/>
</div>

<div class="doc">
<a name="lab35"></a><h2 class="section">Specification of the <span class="inlinecode"><span class="id" type="var">reverse</span></span> function.</h2>
 A <span class="inlinecode"><span class="id" type="var">funspec</span></span> characterizes the precondition required for calling the function
  and the postcondition guaranteed by the function.
 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">reverse_spec</span> : <span class="id" type="var">ident</span> * <span class="id" type="var">funspec</span> :=<br/>
&nbsp;<span class="id" type="var">DECLARE</span> <span class="id" type="var">_reverse</span><br/>
&nbsp;&nbsp;<span class="id" type="var">WITH</span> <span class="id" type="var">sigma</span> : <span class="id" type="var">list</span> <span class="id" type="var">val</span>, <span class="id" type="var">p</span>: <span class="id" type="var">val</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span>  [ <span class="id" type="var">_p</span> <span class="id" type="var">OF</span> (<span class="id" type="var">tptr</span> <span class="id" type="var">t_list</span>) ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_p</span> <span class="id" type="var">p</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">listrep</span> <span class="id" type="var">sigma</span> <span class="id" type="var">p</span>)<br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ (<span class="id" type="var">tptr</span> <span class="id" type="var">t_list</span>) ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">EX</span> <span class="id" type="var">q</span>:<span class="id" type="var">val</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> () <span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">ret_temp</span> <span class="id" type="var">q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">listrep</span>(<span class="id" type="var">rev</span> <span class="id" type="var">sigma</span>) <span class="id" type="var">q</span>).<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> The WITH clause says, there is a value <span class="inlinecode"><span class="id" type="var">sigma</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">val</span></span> 
      and a value <span class="inlinecode"><span class="id" type="var">p</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span>, visible in both the precondition and 
      the postcondition.

</li>
<li> The PREcondition says, 
<ul class="doclist">
<li> There is a single function-parameter named <span class="inlinecode"><span class="id" type="var">_p</span></span>, whose C type is
         "pointer to struct list"

</li>
<li> LOCAL:  The C local variable <span class="inlinecode"><span class="id" type="var">_p</span></span> contains the Coq value <span class="inlinecode"><span class="id" type="var">p</span></span>;

</li>
<li> SEP: in memory at address <span class="inlinecode"><span class="id" type="var">p</span></span> there is a linked list 
          representing <span class="inlinecode"><span class="id" type="var">sigma</span></span>.

</li>
</ul>

</li>
<li> The POSTcondition says, 
<ul class="doclist">
<li> the function returns a value whose C type is 
           "pointer to struct list"; and

</li>
<li> there exists a value <span class="inlinecode"><span class="id" type="var">q</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span>, such that

</li>
<li> LOCAL: the "return temporary", a pseudovariable holdingthe 
           function's return value, holds the value <span class="inlinecode"><span class="id" type="var">q</span></span>

</li>
<li> SEP: in memory at address <span class="inlinecode"><span class="id" type="var">q</span></span> there is a linked list representing
           <span class="inlinecode"><span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">sigma</span></span>.

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

 The global function spec, characterizing the
  preconditions/postconditions of all the functions
  that your proved-correct program will call. 
  Normally you include all the functions here, but
  in this tutorial example we include only one. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Gprog</span> : <span class="id" type="var">funspecs</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ltac</span>:(<span class="id" type="var">with_library</span> <span class="id" type="var">prog</span> [ <span class="id" type="var">reverse_spec</span> ]).<br/>
</div>

<div class="doc">
<a name="lab36"></a><h2 class="section">Proof of the <span class="inlinecode"><span class="id" type="var">reverse</span></span> function</h2>

<div class="paragraph"> </div>

 For each function definition in the C program, prove that the
 function-body (in this case, f_reverse) satisfies its specification
  (in this case, reverse_spec).  
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_reverse</span>: <span class="id" type="var">semax_body</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">f_reverse</span> <span class="id" type="var">reverse_spec</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
</div>

<div class="doc">
The start_function tactic "opens up" a semax_body
    proof goal into a Hoare triple. 
</div>
<div class="code code-tight">
<span class="id" type="var">start_function</span>.<br/>
</div>

<div class="doc">
 As usual, the current assertion (precondition) is derived
     from the PRE clause of the function specification, <span class="inlinecode"><span class="id" type="var">reverse_spec</span></span>,
     and the current command <span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="var">w</span>=0;</span> <span class="inlinecode">...<span class="id" type="var">more</span>...</span> <span class="inlinecode"></span> is the function
     body of <span class="inlinecode"><span class="id" type="var">f_reverse</span></span>. 
<div class="paragraph"> </div>

 The first statement (command) in the function-body is the assignment
     statement  <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span>;</span>, where <span class="inlinecode"><span class="id" type="var">NULL</span></span> is a C <span class="inlinecode">#<span class="id" type="var">define</span></span> that exands to
     "cast 0 to void-pointer", <span class="inlinecode">(<span class="id" type="var">void</span></span> <span class="inlinecode">*</span> <span class="inlinecode">)0</span>, here ugly-printed as <span class="inlinecode">(<span class="id" type="var">tptr</span></span> <span class="inlinecode"><span class="id" type="var">tvoid</span>)(0)</span>.
    To apply the separation-logic assignment rule to this command, simply
     use the tactic <span class="inlinecode"><span class="id" type="var">forward</span></span> : 
</div>
<div class="code code-tight">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;w&nbsp;=&nbsp;NULL;&nbsp;*)</span><br/>
</div>

<div class="doc">
The new <span class="inlinecode"><span class="id" type="var">semax</span></span> judgment is for the rest of the function body <i>after</i>
     the command <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span></span>.  The precondition of this <span class="inlinecode"><span class="id" type="var">semax</span></span> is actually
     the postcondition of the <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span></span> statement.  It's much like the
     precondition of <span class="inlinecode"><span class="id" type="var">w</span>=<span class="id" type="var">NULL</span></span>, but contains the additional LOCAL fact,
     <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_w</span></span> <span class="inlinecode">(<span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">Int.repr</span></span> <span class="inlinecode">0))</span>, that is, the local variable <span class="inlinecode"><span class="id" type="var">_w</span></span> contains <span class="inlinecode"><span class="id" type="var">nullval</span></span>. 
<div class="paragraph"> </div>

 We can view the Hoare-logic proof of this program as a "symbolic execution",
     where the symbolic states are assertions.  We can symbolically execute
     the next command by saying <span class="inlinecode"><span class="id" type="var">forward</span></span> again. 
</div>
<div class="code code-tight">
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;v&nbsp;=&nbsp;p;&nbsp;*)</span><br/>
</div>

<div class="doc">
Examine the precondition, and notice that now we have the additional
    fact, <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_v</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span>. 
<div class="paragraph"> </div>

 We cannot the next step using <span class="inlinecode"><span class="id" type="var">forward</span></span> ... 
</div>
<div class="code code-tight">
<span class="id" type="var">Fail</span> <span class="id" type="var">forward</span>.<br/>
</div>

<div class="doc">
... because the next command is a <span class="inlinecode"><span class="id" type="var">while</span></span> loop.
  To prove a while-loop, you must supply a loop invariant,
    in this case (EX s<sub>1</sub>  PROP(...)LOCAL(...)(SEP(...)).  
</div>
<div class="code code-tight">
<span class="id" type="var">forward_while</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">EX</span> <span class="id" type="var">s<sub>1</sub></span>: <span class="id" type="var">list</span> <span class="id" type="var">val</span>, <span class="id" type="var">EX</span> <span class="id" type="var">s<sub>2</sub></span> : <span class="id" type="var">list</span> <span class="id" type="var">val</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">EX</span> <span class="id" type="var">w</span>: <span class="id" type="var">val</span>, <span class="id" type="var">EX</span> <span class="id" type="var">v</span>: <span class="id" type="var">val</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> (<span class="id" type="var">sigma</span> = <span class="id" type="var">rev</span> <span class="id" type="var">s<sub>1</sub></span> ++ <span class="id" type="var">s<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_w</span> <span class="id" type="var">w</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_v</span> <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">listrep</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">w</span>; <span class="id" type="var">listrep</span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">v</span>)).<br/>
</div>

<div class="doc">
The forward_while tactic leaves four subgoals,
    which we mark with * (the Coq "bullet") 
</div>
<div class="code code-tight">
* <span class="comment">(*&nbsp;Prove&nbsp;that&nbsp;(current)&nbsp;precondition&nbsp;implies&nbsp;the&nbsp;loop&nbsp;invariant&nbsp;*)</span><br/>
<span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
On the left-hand side of this entailment is the precondition
  (that we had already established by forward symbolic execution to this
  point) for the entire while-loop.  On the right-hand side is the loop
  invariant, that we just gave to the <span class="inlinecode"><span class="id" type="var">forward_while</span></span> tactic.  Because
  the right_hand side has for existentials, a good proof strategy is to
  choose values for them, using the <span class="inlinecode"><span class="id" type="var">Exists</span></span> tactic. 
</div>
<div class="code code-tight">
<span class="id" type="var">Exists</span> (@<span class="id" type="var">nil</span> <span class="id" type="var">val</span>) <span class="id" type="var">sigma</span> <span class="id" type="var">nullval</span> <span class="id" type="var">p</span>.<br/>
</div>

<div class="doc">
Now we have a quantifier-free proof goal; let us see whether <span class="inlinecode"><span class="id" type="var">entailer</span>!</span>
    can solve some parts of it. 
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Indeed, the <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> did a fine job.  What's left is a property of our
    user-defined <span class="inlinecode"><span class="id" type="var">listrep</span></span> predicate:  <span class="inlinecode"><span class="id" type="var">emp</span></span> <span class="inlinecode">&#x22A2;-</span> <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode">[]</span> <span class="inlinecode"><span class="id" type="var">nullval</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span>.<br/>
</div>

<div class="doc">
Now that the user-defined predicate is unfolded, <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> can solve
     the residual entailment. 
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(*&nbsp;Prove&nbsp;that&nbsp;loop&nbsp;invariant&nbsp;implies&nbsp;typechecking&nbsp;of&nbsp;loop&nbsp;condition&nbsp;*)</span><br/>
<span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
The second subgoal of <span class="inlinecode"><span class="id" type="var">forward_while</span></span> is to prove that the loop-test
     condition can execute without crashing.   Consider, for example,
     the C-language while loop,  <span class="inlinecode"><span class="id" type="var">while</span></span> <span class="inlinecode">(<span class="id" type="var">a</span>[<span class="id" type="var">i</span>]&gt;0)</span> <span class="inlinecode">...</span>, where the value of <span class="inlinecode"><span class="id" type="var">i</span></span>
     might exceed the bounds of the array.  Then this would be a
     "buffer overrun", and is "undefined behavior" ("stuck") in the C semantics.
     We must prove that, given the current precondition (in this case,
     the loop invariant), the loop test is not "undefined behavior."  
     This proof goal takes the form, <span class="inlinecode"><span class="id" type="var">current</span>-<span class="id" type="var">precondition</span></span> <span class="inlinecode">&#x22A2;-</span> <span class="inlinecode"><span class="id" type="var">tc_expr</span></span> <span class="inlinecode"><span class="id" type="var">Delta</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span>,
     where <span class="inlinecode"><span class="id" type="var">e</span></span> is the loop-test expression.  You can pronounce <span class="inlinecode"><span class="id" type="var">tc_expr</span></span> as
     "type-check expression", since the Verifiable C type-checker ensures
     that such expressions are safe (sometimes with a subgoal for you to prove).

<div class="paragraph"> </div>

     Fortunately, in most cases the <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> solves <span class="inlinecode"><span class="id" type="var">tc_expr</span></span> goals 
     completely automatically:  
</div>
<div class="code code-tight">
<span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(*&nbsp;Prove&nbsp;that&nbsp;loop&nbsp;body&nbsp;preserves&nbsp;invariant&nbsp;*)</span><br/>
<span class="id" type="var">hint</span>.<br/>
</div>

<div class="doc">
As usual in any Hoare logic (including Separation Logic), we need to prove
   that the loop body preserves the loop invariant, more precisely,

<div class="paragraph"> </div>

<ul class="doclist">
<li> {Inv /\ Test} body {Inv}

</li>
</ul>
   where Test is the loop-test condition.  Here, the loop-test condition
   in the original C code is <span class="inlinecode">(<span class="id" type="var">v</span>)</span>, and its manifestation above the line is
   the hypothesis <span class="inlinecode"><span class="id" type="var">HRE</span>:</span> <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">v</span></span>, meaning that <span class="inlinecode"><span class="id" type="var">v</span></span> is a (non-null) pointer.

<div class="paragraph"> </div>

   The loop invariant was <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>:_,</span> <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>:_,</span> <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">w</span>:_,</span> <span class="inlinecode"><span class="id" type="var">EX</span></span> <span class="inlinecode"><span class="id" type="var">v</span>:_,</span> <span class="inlinecode">...</span>, and here
   all the existentially quantified variables on the left side of the entailment
   have been moved above the line:  <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span> and <span class="inlinecode"><span class="id" type="var">w</span>,<span class="id" type="var">v</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span></span>.

<div class="paragraph"> </div>

   The PROP part of the loop invariant was <span class="inlinecode"><span class="id" type="var">sigma</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">rev</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span>, and 
   it has also been moved above the line, as hypothesis <span class="inlinecode"><span class="id" type="var">H</span></span>.

<div class="paragraph"> </div>

   So now we would like to do forward-symbolic execution through
   the four assignment statements in the loop body. 
</div>
<div class="code code-tight">
<span class="id" type="var">Fail</span> <span class="id" type="var">forward</span>.<br/>
</div>

<div class="doc">
But we cannot go forward through <span class="inlinecode"><span class="id" type="var">t</span>=<span class="id" type="var">v</span>→<span class="id" type="var">tail</span>;</span> because that would
   require a SEP conjunct in the precondition of the form 
   <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">sh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">_</span>,_)</span> <span class="inlinecode"><span class="id" type="var">v</span></span>, and there is no such conjunct.  Actually,
   there is such a conjunct, but it is hiding inside <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> <span class="inlinecode"><span class="id" type="var">v</span></span>.
   That is, there is such a conjunct as long as <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> is not <span class="inlinecode"><span class="id" type="var">nil</span></span>.
   Let's do case analysis on s<sub>2</sub>: 
</div>
<div class="code code-tight">
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">h</span> <span class="id" type="var">r</span>].<br/>
&nbsp;- <span class="comment">(*&nbsp;s<sub>2</sub>=nil&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(**&nbsp;Suppose&nbsp;<span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>=<span class="id" type="var">nil</span></span>.&nbsp;&nbsp;If&nbsp;we&nbsp;unfold&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span>&nbsp;.&nbsp;.&nbsp;.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span> <span class="id" type="tactic">at</span> 2.<br/>
</div>

<div class="doc">
then we learn that <span class="inlinecode"><span class="id" type="var">v</span>=<span class="id" type="var">nullval</span></span>.  To move this fact (or any proposition)
    from the precondition to above-the-line, we use <span class="inlinecode"><span class="id" type="var">Intros</span></span>: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Intros</span>.<br/>
</div>

<div class="doc">
Now, above the line, we have <span class="inlinecode"><span class="id" type="var">v</span>=<span class="id" type="var">nullval</span></span> and <span class="inlinecode"><span class="id" type="var">isptr</span></span> <span class="inlinecode"><span class="id" type="var">v</span></span>; this is a contradiction. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">subst</span>. <span class="id" type="var">contradiction</span>.<br/>
&nbsp;- <span class="comment">(*&nbsp;s<sub>2</sub>=h::r&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(**&nbsp;Suppose&nbsp;<span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span>=<span class="id" type="var">h</span>::<span class="id" type="var">r</span></span>.&nbsp;&nbsp;We&nbsp;can&nbsp;unfold/fold&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">listrep</span></span>&nbsp;conjunct&nbsp;for&nbsp;<span class="inlinecode"><span class="id" type="var">h</span>::<span class="id" type="var">r</span></span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;you&nbsp;don't&nbsp;remember&nbsp;why&nbsp;we&nbsp;do&nbsp;<span class="inlinecode"><span class="id" type="tactic">unfold</span>/<span class="id" type="var">fold</span></span>,&nbsp;then&nbsp;replace&nbsp;the&nbsp;semicolon<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(between&nbsp;the&nbsp;fold&nbsp;and&nbsp;the&nbsp;unfold)&nbsp;with&nbsp;a&nbsp;period&nbsp;and&nbsp;see&nbsp;what&nbsp;happens.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span> <span class="id" type="tactic">at</span> 2; <span class="id" type="var">fold</span> <span class="id" type="var">listrep</span>.<br/>
</div>

<div class="doc">
By the definition of <span class="inlinecode"><span class="id" type="var">listrep</span></span>, at address <span class="inlinecode"><span class="id" type="var">v</span></span> there must exist a value <span class="inlinecode"><span class="id" type="var">y</span></span>
     and a list cell containing (h,y).  So let us move <span class="inlinecode"><span class="id" type="var">y</span></span> above the line: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Intros</span> <span class="id" type="var">y</span>.<br/>
</div>

<div class="doc">
Now we have the appropriate SEP conjuncts to be able to go <span class="inlinecode"><span class="id" type="var">forward</span></span>
   through the loop body 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;t&nbsp;=&nbsp;v<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>tail&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;v<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>tail&nbsp;=&nbsp;w;&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;w&nbsp;=&nbsp;v;&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;v&nbsp;=&nbsp;t;&nbsp;*)</span><br/>
</div>

<div class="doc">
At the end of loop body; we must reestablish the loop invariant.
   The left-hand-side of this entailment is the current assertion (after
   the loop body); the right-hand side is simply our loop invariant.
   (Unfortunately, the <span class="inlinecode"><span class="id" type="var">forward_while</span></span> tactic has "uncurried" the existentials
   into a single EX that binds a 4-tuple.)
   Since the proof goal is a complicated-looking entailment, let's see
   if <span class="inlinecode"><span class="id" type="var">entailer</span>!</span> can simplify it a bit: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
</div>

<div class="doc">
Now, we can provide new values for <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">s<sub>2</sub></span>,<span class="id" type="var">w</span>,<span class="id" type="var">v</span></span> to instantiate the 
   four existentials; these are, respectively, <span class="inlinecode"><span class="id" type="var">h</span>::<span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">r</span>,<span class="id" type="var">v</span>,<span class="id" type="var">y</span></span>. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">Exists</span> (<span class="id" type="var">h</span>::<span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">r</span>,<span class="id" type="var">v</span>,<span class="id" type="var">y</span>).<br/>
</div>

<div class="doc">
Again, we have a complicated-looking entailment; we ask <span class="inlinecode"><span class="id" type="var">entailer</span>!</span>
   to reduce it some more. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">entailer</span>!.<br/>
&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">app_ass</span>. <span class="id" type="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span> <span class="id" type="tactic">at</span> 3; <span class="id" type="var">fold</span> <span class="id" type="var">listrep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Exists</span> <span class="id" type="var">w</span>. <span class="id" type="var">entailer</span>!.<br/>
* <span class="comment">(*&nbsp;after&nbsp;the&nbsp;loop&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="comment">(**&nbsp;As&nbsp;usual&nbsp;in&nbsp;any&nbsp;Hoare&nbsp;logic&nbsp;(including&nbsp;Separation&nbsp;Logic),&nbsp;the&nbsp;postcondition<br/>
&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;a&nbsp;while-loop&nbsp;is&nbsp;{Inv&nbsp;/\&nbsp;not&nbsp;Test},&nbsp;where&nbsp;Inv&nbsp;is&nbsp;the&nbsp;loop&nbsp;invariant<br/>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;Test&nbsp;is&nbsp;the&nbsp;loop&nbsp;test.&nbsp;&nbsp;Here,&nbsp;all&nbsp;the&nbsp;EXistentials&nbsp;and&nbsp;PROPs&nbsp;of&nbsp;the<br/>
&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;invariant&nbsp;have&nbsp;been&nbsp;moved&nbsp;above&nbsp;the&nbsp;line&nbsp;as&nbsp;<span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">s<sub>2</sub></span>,<span class="id" type="var">w</span>,<span class="id" type="var">v</span>,<span class="id" type="var">HRE</span>,<span class="id" type="var">H</span></span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;We&nbsp;can&nbsp;always&nbsp;go&nbsp;<span class="inlinecode"><span class="id" type="var">forward</span></span>&nbsp;through&nbsp;a&nbsp;<span class="inlinecode"><span class="id" type="keyword">return</span></span>&nbsp;statement:&nbsp;*)</span><br/>
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;return&nbsp;w;&nbsp;*)</span><br/>
</div>

<div class="doc">
Now we must prove that the current assertion (after the while-loop)
  entails the function postcondition.  The left-hand side of this entailment
  is what we had just before <span class="inlinecode"><span class="id" type="var">forward</span></span> through the <span class="inlinecode"><span class="id" type="keyword">return</span></span>;
  the right-hand side is the postcondition of <span class="inlinecode"><span class="id" type="var">reverse_spec</span></span>,
  after the local variables (etc.) have been simplified away.  We must
  demonstrate a pointer <span class="inlinecode"><span class="id" type="var">q</span></span> (here it's called <span class="inlinecode"><span class="id" type="var">x</span></span>) that satisfies the various
  conditions.  Here it's easy to find <span class="inlinecode"><span class="id" type="var">x</span></span>, since it's constrained to be
  equal to <span class="inlinecode"><span class="id" type="var">w</span></span>: 
</div>
<div class="code code-tight">
<span class="id" type="var">Exists</span> <span class="id" type="var">w</span>; <span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">proj1</span> <span class="id" type="var">H<sub>1</sub></span>) <span class="id" type="tactic">by</span> <span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span> <span class="id" type="tactic">at</span> 2; <span class="id" type="var">fold</span> <span class="id" type="var">listrep</span>.<br/>
<span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">app_nil_end</span>, <span class="id" type="var">rev_involutive</span>.<br/>
<span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab37"></a><h2 class="section">Why separation logic?</h2>

<div class="paragraph"> </div>

 If we review our functional correctness proof for <span class="inlinecode"><span class="id" type="var">reverse.c</span></span>, it may
  not be obvious why we need separation logic at all. Let's take a close look.

<div class="paragraph"> </div>

First, we build "separation" into the definition of <span class="inlinecode"><span class="id" type="var">listrep</span></span>. The following is
our definition:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span>&nbsp;<span class="id" type="var">listrep</span>&nbsp;(<span class="id" type="var">sigma</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">val</span>)&nbsp;(<span class="id" type="var">p</span>:&nbsp;<span class="id" type="var">val</span>)&nbsp;:&nbsp;<span class="id" type="var">mpred</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span>&nbsp;<span class="id" type="var">sigma</span>&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">h</span>::<span class="id" type="var">hs</span>&nbsp;⇒&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">EX</span>&nbsp;<span class="id" type="var">y</span>:<span class="id" type="var">val</span>,&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">Tsh</span>&nbsp;<span class="id" type="var">t_list</span>&nbsp;(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)&nbsp;<span class="id" type="var">p</span>&nbsp;&nbsp;*&nbsp;&nbsp;<span class="id" type="var">listrep</span>&nbsp;<span class="id" type="var">hs</span>&nbsp;<span class="id" type="var">y</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">nil</span>&nbsp;⇒&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!!&nbsp;(<span class="id" type="var">p</span>&nbsp;=&nbsp;<span class="id" type="var">nullval</span>)&nbsp;&amp;&amp;&nbsp;<span class="id" type="var">emp</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.
<div class="paragraph"> </div>

</div>
In the nonempty list case, the head element is described by

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">Tsh</span>&nbsp;<span class="id" type="var">t_list</span>&nbsp;(<span class="id" type="var">h</span>,<span class="id" type="var">y</span>)&nbsp;<span class="id" type="var">p</span>
<div class="paragraph"> </div>

</div>
which is separated (by the separating conjunction * ) from the rest of the list

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span>&nbsp;<span class="id" type="var">hs</span>&nbsp;<span class="id" type="var">y</span>.
<div class="paragraph"> </div>

</div>
This separation ensures that no address could be used for more than once in a
linked list. For example, considering a linked list of length at least 2,

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span>&nbsp;(<span class="id" type="var">a</span>&nbsp;::&nbsp;<span class="id" type="var">b</span>&nbsp;::&nbsp;<span class="id" type="var">l</span>)&nbsp;<span class="id" type="var">x</span>.
<div class="paragraph"> </div>

</div>
We know that there must be two addresses <span class="inlinecode"><span class="id" type="var">y</span></span> and <span class="inlinecode"><span class="id" type="var">z</span></span> such that

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">Tsh</span>&nbsp;<span class="id" type="var">t_list</span>&nbsp;(<span class="id" type="var">a</span>,<span class="id" type="var">y</span>)&nbsp;<span class="id" type="var">x</span>&nbsp;*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">Tsh</span>&nbsp;<span class="id" type="var">t_list</span>&nbsp;(<span class="id" type="var">b</span>,<span class="id" type="var">z</span>)&nbsp;<span class="id" type="var">y</span>&nbsp;*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span>&nbsp;<span class="id" type="var">l</span>&nbsp;<span class="id" type="var">z</span>.
<div class="paragraph"> </div>

</div>
The "separating conjunction" <span class="inlinecode">*</span> tells us that <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">y</span></span> must be different!
Formally, we can prove the following two lemmas:

</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">listrep_len_ge2_fact</span>: <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">x</span>: <span class="id" type="var">val</span>) (<span class="id" type="var">l</span>: <span class="id" type="var">list</span> <span class="id" type="var">val</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">listrep</span> (<span class="id" type="var">a</span> :: <span class="id" type="var">b</span> :: <span class="id" type="var">l</span>) <span class="id" type="var">x</span> &#x22A2;-<br/>
&nbsp;&nbsp;<span class="id" type="var">EX</span> <span class="id" type="var">y</span>: <span class="id" type="var">val</span>, <span class="id" type="var">EX</span> <span class="id" type="var">z</span>: <span class="id" type="var">val</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">a</span>,<span class="id" type="var">y</span>) <span class="id" type="var">x</span> *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">b</span>,<span class="id" type="var">z</span>) <span class="id" type="var">y</span> *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">listrep</span> <span class="id" type="var">l</span> <span class="id" type="var">z</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">listrep</span>; <span class="id" type="var">fold</span> <span class="id" type="var">listrep</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Intros</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Exists</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">cancel</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">listrep_len_ge2_address_different</span>: <span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span>: <span class="id" type="var">val</span>) (<span class="id" type="var">l</span>: <span class="id" type="var">list</span> <span class="id" type="var">val</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">a</span>,<span class="id" type="var">y</span>) <span class="id" type="var">x</span> *<br/>
&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">b</span>,<span class="id" type="var">z</span>) <span class="id" type="var">y</span> *<br/>
&nbsp;&nbsp;<span class="id" type="var">listrep</span> <span class="id" type="var">l</span> <span class="id" type="var">z</span> &#x22A2;-<br/>
&nbsp;&nbsp;!! (<span class="id" type="var">x</span> ≠ <span class="id" type="var">y</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
To prove that the addresses are different, we do case analysis first.
    If <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">y</span></span>, we use the following theorem: 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="keyword">Check</span> <span class="id" type="var">data_at_conflict</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;:&nbsp;forall&nbsp;(sh&nbsp;:&nbsp;Share.t)&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(v&nbsp;v'&nbsp;:&nbsp;reptype&nbsp;t)&nbsp;(p&nbsp;:&nbsp;val),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sepalg.nonidentity&nbsp;sh&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;0&nbsp;&lt;&nbsp;sizeof&nbsp;t&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_at&nbsp;sh&nbsp;t&nbsp;v&nbsp;p&nbsp;*&nbsp;data_at&nbsp;sh&nbsp;t&nbsp;v'&nbsp;p&nbsp;&#x22A2;-&nbsp;FF&nbsp;*)</span><br/>
</div>

<div class="doc">
It says that we can derives address anti-aliasing from the "separation"
    defined by <span class="inlinecode">*</span>.  If <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" type="var">y</span></span>, the right side is already proved. 
</div>
<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">Val.eq</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); [| <span class="id" type="tactic">apply</span> <span class="id" type="var">prop_right</span>; <span class="id" type="tactic">auto</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">subst</span> <span class="id" type="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">sep_apply</span> (<span class="id" type="var">data_at_conflict</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">a</span>, <span class="id" type="var">y</span>)).<br/>
&nbsp;&nbsp;+ <span class="id" type="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id" type="var">entailer</span>!.<br/>
<span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;Actually,&nbsp;even&nbsp;the&nbsp;property&nbsp;<span class="inlinecode"><span class="id" type="var">x</span>≠<span class="id" type="var">y</span></span>&nbsp;is&nbsp;not&nbsp;strong&nbsp;enough!&nbsp;&nbsp;We&nbsp;need&nbsp;to&nbsp;<br/>
&nbsp;&nbsp;know&nbsp;that&nbsp;<span class="inlinecode"><span class="id" type="var">x</span></span>&nbsp;does&nbsp;not&nbsp;overlap&nbsp;with&nbsp;_any&nbsp;field_&nbsp;of&nbsp;record&nbsp;<span class="inlinecode"><span class="id" type="var">y</span></span>,&nbsp;<br/>
&nbsp;&nbsp;for&nbsp;example&nbsp;(in&nbsp;C&nbsp;notation)&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">!=</span> <span class="inlinecode">&amp;(<span class="id" type="var">y</span>→<span class="id" type="var">tail</span>)</span>&nbsp;and&nbsp;<span class="inlinecode">&amp;(<span class="id" type="var">x</span>→<span class="id" type="var">tail</span>)</span> <span class="inlinecode">!=</span> <span class="inlinecode"><span class="id" type="var">y</span></span>.<br/>
&nbsp;&nbsp;Otherwise,&nbsp;when&nbsp;storing&nbsp;into&nbsp;<span class="inlinecode"><span class="id" type="var">y</span>→<span class="id" type="var">tail</span></span>,&nbsp;we&nbsp;couldn't&nbsp;know&nbsp;that&nbsp;<span class="inlinecode"><span class="id" type="var">x</span>→<span class="id" type="var">head</span></span><br/>
&nbsp;&nbsp;is&nbsp;not&nbsp;altered.&nbsp;*)</span><br/>
</div>

<div class="doc">
Without separation logic, we could still define <span class="inlinecode"><span class="id" type="var">listrep'</span></span> using extra
clauses for address anti-aliasing. For example, a length-3 linked list
<span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode">(<span class="id" type="var">a</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">nil</span>)</span> <span class="inlinecode"><span class="id" type="var">x</span></span> can be: exists <span class="inlinecode"><span class="id" type="var">y</span></span> and <span class="inlinecode"><span class="id" type="var">z</span></span>, such that <span class="inlinecode">(<span class="id" type="var">a</span>,</span> <span class="inlinecode"><span class="id" type="var">y</span>)</span>
is stored at <span class="inlinecode"><span class="id" type="var">x</span></span>, <span class="inlinecode">(<span class="id" type="var">b</span>,</span> <span class="inlinecode"><span class="id" type="var">z</span>)</span> is stored at <span class="inlinecode"><span class="id" type="var">y</span></span>, <span class="inlinecode">(<span class="id" type="var">c</span>,</span> <span class="inlinecode"><span class="id" type="var">nullval</span>)</span> is stored at <span class="inlinecode"><span class="id" type="var">z</span></span> and
<span class="inlinecode"><span class="id" type="var">x</span></span>, <span class="inlinecode"><span class="id" type="var">y</span></span> and <span class="inlinecode"><span class="id" type="var">z</span></span> are different from each other. In general, that assertion will
be quadratically long (as a function of the length of the linked list). 
Then, to make sure <span class="inlinecode"><span class="id" type="var">x</span>→<span class="id" type="var">head</span></span> is not at the same address as <span class="inlinecode"><span class="id" type="var">y</span>→<span class="id" type="var">tail</span></span>, we'd need 
even more assertions. 
<div class="paragraph"> </div>

 In our program correctness proof, we do (implicitly) use the fact that 
different <span class="inlinecode"><span class="id" type="var">SEP</span></span> clauses describe disjoint heaplets. Here is an
intermediate step in the proof of <span class="inlinecode"><span class="id" type="var">body_reverse</span></span>.

<div class="paragraph"> </div>

 (We rarely state intermediate proof goals such as this one.
  We do it here to illustrate a point about separating conjunction.  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_reverse_step</span>: <span style='font-size:120%;'>&forall;</span><br/>
&nbsp;&nbsp;{<span class="id" type="var">Espec</span> : <span class="id" type="var">OracleKind</span>}<br/>
&nbsp;&nbsp;(<span class="id" type="var">sigma</span> : <span class="id" type="var">list</span> <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">s<sub>1</sub></span> : <span class="id" type="var">list</span> <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">h</span> : <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">r</span> : <span class="id" type="var">list</span> <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">w</span> <span class="id" type="var">v</span> : <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">HRE</span> : <span class="id" type="var">isptr</span> <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">H</span> : <span class="id" type="var">sigma</span> = <span class="id" type="var">rev</span> <span class="id" type="var">s<sub>1</sub></span> ++ <span class="id" type="var">h</span> :: <span class="id" type="var">r</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">y</span> : <span class="id" type="var">val</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">semax</span> (<span class="id" type="var">func_tycontext</span> <span class="id" type="var">f_reverse</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span> <span class="id" type="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">PROP</span> ( )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_t</span> <span class="id" type="var">y</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_w</span> <span class="id" type="var">w</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_v</span> <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">listrep</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">w</span>; <span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">h</span>, <span class="id" type="var">y</span>) <span class="id" type="var">v</span>; <span class="id" type="var">listrep</span> <span class="id" type="var">r</span> <span class="id" type="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Ssequence</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Sassign</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Efield</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Ederef</span> (<span class="id" type="var">Etempvar</span> <span class="id" type="var">_v</span> (<span class="id" type="var">tptr</span> (<span class="id" type="var">Tstruct</span> <span class="id" type="var">_list</span> <span class="id" type="var">noattr</span>))) (<span class="id" type="var">Tstruct</span> <span class="id" type="var">_list</span> <span class="id" type="var">noattr</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">_tail</span> (<span class="id" type="var">tptr</span> (<span class="id" type="var">Tstruct</span> <span class="id" type="var">_list</span> <span class="id" type="var">noattr</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Etempvar</span> <span class="id" type="var">_w</span> (<span class="id" type="var">tptr</span> (<span class="id" type="var">Tstruct</span> <span class="id" type="var">_list</span> <span class="id" type="var">noattr</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Ssequence</span> (<span class="id" type="var">Sset</span> <span class="id" type="var">_w</span> (<span class="id" type="var">Etempvar</span> <span class="id" type="var">_v</span> (<span class="id" type="var">tptr</span> (<span class="id" type="var">Tstruct</span> <span class="id" type="var">_list</span> <span class="id" type="var">noattr</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Sset</span> <span class="id" type="var">_v</span> (<span class="id" type="var">Etempvar</span> <span class="id" type="var">_t</span> (<span class="id" type="var">tptr</span> (<span class="id" type="var">Tstruct</span> <span class="id" type="var">_list</span> <span class="id" type="var">noattr</span>))))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">normal_ret_assert</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">PROP</span> ( )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_v</span> <span class="id" type="var">y</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_w</span> <span class="id" type="var">v</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_t</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">listrep</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">w</span>; <span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">t_list</span> (<span class="id" type="var">h</span>, <span class="id" type="var">w</span>) <span class="id" type="var">v</span>; <span class="id" type="var">listrep</span> <span class="id" type="var">r</span> <span class="id" type="var">y</span>))).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">abbreviate_semax</span>.<br/>
</div>

<div class="doc">
Now, our proof goal is:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">semax</span>&nbsp;<span class="id" type="var">Delta</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">PROP</span>&nbsp;(&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span>&nbsp;(<span class="id" type="var">temp</span>&nbsp;<span class="id" type="var">_t</span>&nbsp;<span class="id" type="var">y</span>;&nbsp;<span class="id" type="var">temp</span>&nbsp;<span class="id" type="var">_w</span>&nbsp;<span class="id" type="var">w</span>;&nbsp;<span class="id" type="var">temp</span>&nbsp;<span class="id" type="var">_v</span>&nbsp;<span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span>&nbsp;(<span class="id" type="var">listrep</span>&nbsp;<span class="id" type="var">s<sub>1</sub></span>&nbsp;<span class="id" type="var">w</span>;&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">Tsh</span>&nbsp;<span class="id" type="var">t_list</span>&nbsp;(<span class="id" type="var">h</span>,&nbsp;<span class="id" type="var">y</span>)&nbsp;<span class="id" type="var">v</span>;&nbsp;<span class="id" type="var">listrep</span>&nbsp;<span class="id" type="var">r</span>&nbsp;<span class="id" type="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">_v</span>&nbsp;→&nbsp;<span class="id" type="var">_tail</span>)&nbsp;=&nbsp;<span class="id" type="var">_w</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">MORE_COMMANDS</span>)&nbsp;<span class="id" type="var">POSTCONDITION</span>.
<div class="paragraph"> </div>

</div>
The next <span class="inlinecode"><span class="id" type="var">forward</span></span> tactic will execute a symbolic execution for <span class="inlinecode"><span class="id" type="var">v</span>→<span class="id" type="var">tail</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">w</span></span>.

</div>
<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;v<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>tail&nbsp;=&nbsp;w;&nbsp;*)</span><br/>
</div>

<div class="doc">
It turns the precondition into:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span>&nbsp;(&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span>&nbsp;(<span class="id" type="var">temp</span>&nbsp;<span class="id" type="var">_t</span>&nbsp;<span class="id" type="var">y</span>;&nbsp;<span class="id" type="var">temp</span>&nbsp;<span class="id" type="var">_w</span>&nbsp;<span class="id" type="var">w</span>;&nbsp;<span class="id" type="var">temp</span>&nbsp;<span class="id" type="var">_v</span>&nbsp;<span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span>&nbsp;(<span class="id" type="var">listrep</span>&nbsp;<span class="id" type="var">s<sub>1</sub></span>&nbsp;<span class="id" type="var">w</span>;&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">Tsh</span>&nbsp;<span class="id" type="var">t_list</span>&nbsp;(<span class="id" type="var">h</span>,&nbsp;<span class="id" type="var">w</span>)&nbsp;<span class="id" type="var">v</span>;&nbsp;<span class="id" type="var">listrep</span>&nbsp;<span class="id" type="var">r</span>&nbsp;<span class="id" type="var">y</span>).
<div class="paragraph"> </div>

</div>
It is no problem that the separating conjunct <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>,</span> <span class="inlinecode"><span class="id" type="var">y</span>)</span> <span class="inlinecode"><span class="id" type="var">v</span></span> is
turned into <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">t_list</span></span> <span class="inlinecode">(<span class="id" type="var">h</span>,</span> <span class="inlinecode"><span class="id" type="var">w</span>)</span> <span class="inlinecode"><span class="id" type="var">v</span></span>. But why weren't the other separating
conjuncts like <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode"><span class="id" type="var">w</span></span> affected?

<div class="paragraph"> </div>

Because they are separated! The separation ensures that address <span class="inlinecode"><span class="id" type="var">v</span></span> is not used
in the linked list described by <span class="inlinecode"><span class="id" type="var">listrep</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode"><span class="id" type="var">w</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
When C programs manipulate pointer data structures (or slices of arrays),
  address anti-aliasing plays an important role in their  correctness proofs.
  Separation logic is essential for reasoning about updates to these structures.
  Verifiable C's SEP clause ensures separation between all its conjuncts. 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;Wed&nbsp;Apr&nbsp;24&nbsp;08:45:36&nbsp;EDT&nbsp;2019&nbsp;*)</span><br/>
</div>
</div>



</div>

</body>
</html>