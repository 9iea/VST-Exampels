<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>Verif_strlib: String functions</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/vc.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 5beta: Verifiable C</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>Table of Contents</li></a>
   <a href='coqindex.html'><li class='section_name'>Index</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">Verif_strlib<span class="subtitle">String functions</span></h1>


<div class="doc">

<div class="paragraph"> </div>

 In this chapter we show how to prove the correctness of C programs
 that use null-terminated character strings.  
<div class="paragraph"> </div>

<a name="lab99"></a><h2 class="section">Here are some functions from the C standard library, <span class="inlinecode"><span class="id" type="var">strlib.c</span></span></h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<pre>
#include &lt;stddef.h&gt;

size_t strlen(const char *str) {
  size_t i;
  for (i=0; ; i++)
    if (str[i]==0) return i;
}

char *strcpy(char *dest, const char *src) {
  size_t i;
  for(i = 0;; i++){
    char d = src[i];
    dest[i] = d;
    if(d == 0) return dest;
  }
}

int strcmp(const char *str1, const char *str2) {
  size_t i;
  for(i = 0;; i++){
    char d<sub>1</sub> = str1[i];
    char d<sub>2</sub> = str2[i];
    if(d<sub>1</sub> == 0 &amp;&amp; d<sub>2</sub> == 0) return 0;
    else if(d<sub>1</sub> &lt; d<sub>2</sub>) return -1;
    else if(d<sub>1</sub> &gt; d<sub>2</sub>) return 1;
  }
}    
</pre>

<div class="paragraph"> </div>

<a name="lab100"></a><h2 class="section">Standard boilerplate</h2>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">VST.floyd.proofauto</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">VC.strlib</span>.<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">CompSpecs</span> : <span class="id" type="var">compspecs</span>. <span class="id" type="var">make_compspecs</span> <span class="id" type="var">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Vprog</span> : <span class="id" type="var">varspecs</span>. <span class="id" type="var">mk_varspecs</span> <span class="id" type="var">prog</span>. <span class="id" type="keyword">Defined</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">VC.hints</span>. <span class="comment">(*&nbsp;Import&nbsp;special&nbsp;hints&nbsp;for&nbsp;this&nbsp;tutorial.&nbsp;*)</span><br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Coq.Strings.Ascii</span>.<br/>
</div>

<div class="doc">
<a name="lab101"></a><h2 class="section">Representation of null-terminated strings.</h2>

<div class="paragraph"> </div>

 Coq represents a string as a list-like Inductive of Ascii
    characters: 
</div>
<div class="code code-tight">
<span class="id" type="var">Locate</span> <span class="id" type="var">string</span>. <span class="comment">(*&nbsp;Coq.Strings.String.string&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">string</span>.<br/>
<span class="comment">(*&nbsp;Inductive&nbsp;string&nbsp;:&nbsp;Set&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;EmptyString&nbsp;:&nbsp;string&nbsp;|&nbsp;String&nbsp;:&nbsp;Ascii.ascii&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;string&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;string&nbsp;*)</span><br/>
</div>

<div class="doc">
The C programming language represents a <i>character</i> as
   a byte, that is, an 8-bit signed or unsigned integer.
   In Coq represent the 8-bit integers using the <span class="inlinecode"><span class="id" type="var">byte</span></span> type. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">byte</span>. <span class="comment">(*&nbsp;Notation&nbsp;byte&nbsp;:=&nbsp;Byte.int&nbsp;*)</span><br/>
</div>

<div class="doc">
CompCert's <span class="inlinecode"><span class="id" type="var">Byte</span></span> module is an 8-bit instantiation of
   the n-bit integers, just as the <span class="inlinecode"><span class="id" type="var">Int</span></span> module is a 32-bit
   instantiation. 

<div class="paragraph"> </div>

   Here, we can ask what <span class="inlinecode"><span class="id" type="var">Byte</span></span> knows about the theory of 8-bit
   modular integers: 
</div>
<div class="code code-tight">

<span class="id" type="var">Search</span> <span class="id" type="var">byte</span>. <span class="comment">(*&nbsp;Too&nbsp;long&nbsp;a&nbsp;list&nbsp;of&nbsp;theorems&nbsp;to&nbsp;reproduce&nbsp;here!&nbsp;*)</span><br/>
</div>

<div class="doc">
We can convert a Coq string to a list of bytes: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">string_to_list_byte</span> (<span class="id" type="var">s</span>: <span class="id" type="var">string</span>) : <span class="id" type="var">list</span> <span class="id" type="var">byte</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">s</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EmptyString</span> ⇒ <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">String</span> <span class="id" type="var">a</span> <span class="id" type="var">s'</span> ⇒ <span class="id" type="var">Byte.repr</span> (<span class="id" type="var">Z.of_N</span> (<span class="id" type="var">Ascii.N_of_ascii</span> <span class="id" type="var">a</span>))                                      :: <span class="id" type="var">string_to_list_byte</span> <span class="id" type="var">s'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Hello</span> := "Hello"%<span class="id" type="var">string</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Hello'</span> := <span class="id" type="var">string_to_list_byte</span> <span class="id" type="var">Hello</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">string_to_list_byte</span> <span class="id" type="var">Hello</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;=&nbsp;<span class="inlinecode"><span class="id" type="var">Byte.repr</span></span> <span class="inlinecode">72;</span> <span class="inlinecode"><span class="id" type="var">Byte.repr</span></span> <span class="inlinecode">101;</span> <span class="inlinecode"><span class="id" type="var">Byte.repr</span></span> <span class="inlinecode">108;</span> 
      <span class="inlinecode"><span class="id" type="var">Byte.repr</span></span> <span class="inlinecode">108;</span> <span class="inlinecode"><span class="id" type="var">Byte.repr</span></span> <span class="inlinecode">111</span>&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;list&nbsp;byte&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Section</span> <span class="id" type="var">StringDemo</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <span class="id" type="var">p</span> : <span class="id" type="var">val</span>. <span class="comment">(*&nbsp;Suppose&nbsp;we&nbsp;have&nbsp;an&nbsp;address&nbsp;in&nbsp;memory&nbsp;*)</span><br/>
</div>

<div class="doc">
To describe a single byte in memory, we can use <span class="inlinecode"><span class="id" type="var">data_at</span></span>
   with the signed-character type: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">tschar</span>. <span class="comment">(*&nbsp;=&nbsp;Tint&nbsp;I<sub>8</sub>&nbsp;Signed&nbsp;noattr&nbsp;:&nbsp;type&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">tschar</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> 72)) <span class="id" type="var">p</span>). <span class="comment">(*&nbsp;:&nbsp;mpred&nbsp;*)</span><br/>
</div>

<div class="doc">
This <span class="inlinecode"><span class="id" type="var">data_at</span></span> <span class="inlinecode"><span class="id" type="var">Tsh</span></span> <span class="inlinecode"><span class="id" type="var">tschar</span></span> <span class="inlinecode">(<span class="id" type="var">Vint</span></span> <span class="inlinecode">(<span class="id" type="var">Int.repr</span></span> <span class="inlinecode">72))</span> <span class="inlinecode"><span class="id" type="var">p</span></span> is an <span class="inlinecode"><span class="id" type="var">mpred</span></span>,
   that is, a memory predicate in separation logic.  It says, at
   address <span class="inlinecode"><span class="id" type="var">p</span></span> in memory there is a sequence of bytes whose length
   is appropriate for type <span class="inlinecode"><span class="id" type="var">tschar</span></span>;  that is, one byte.  The
   contents of this sequence of bytes (one byte) is a representation
   of the integer 72. The ownership share (access permission) of
   memory at address <span class="inlinecode"><span class="id" type="var">p</span></span> is the "top share" <span class="inlinecode"><span class="id" type="var">Tsh</span></span> 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> (<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">tschar</span> (<span class="id" type="var">Vbyte</span> (<span class="id" type="var">Byte.repr</span> 72))).<br/>
</div>

<div class="doc">
We can express the same thing using <span class="inlinecode"><span class="id" type="var">Vbyte</span></span> <span class="inlinecode">(<span class="id" type="var">Byte.repr</span></span> <span class="inlinecode">72)</span>.
    In fact, <span class="inlinecode"><span class="id" type="var">Vbyte</span></span> is not a primitive CompCert value,
    it is a definition: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">Vbyte</span>. <span class="comment">(*&nbsp;=&nbsp;fun&nbsp;c&nbsp;:&nbsp;byte&nbsp;=&gt;&nbsp;Vint&nbsp;(Int.repr&nbsp;(Byte.signed&nbsp;c))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;byte&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;val&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Goal</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">Byte.repr</span> 72) = <span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> 72).<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Goal</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">Byte.repr</span> 72) = <span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> 72).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">Vbyte</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Byte.signed_repr</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">rep_omega</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The C programming language represents a string of length <span class="inlinecode"><span class="id" type="var">k</span></span>
   as an array of nonnull characters (bytes), terminated
   by a null character.  We represent this in separation
   logic using the <span class="inlinecode"><span class="id" type="var">cstring</span></span> memory-predicate: 
</div>
<div class="code code-tight">
<span class="id" type="var">Locate</span> <span class="id" type="var">cstring</span>. <span class="comment">(*&nbsp;VST.floyd.entailer.cstring&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">cstring</span>. <span class="comment">(*&nbsp;=<br/>
&nbsp;&nbsp;fun&nbsp;{CS&nbsp;:&nbsp;compspecs}&nbsp;(sh&nbsp;:&nbsp;Share.t)&nbsp;(s&nbsp;:&nbsp;list&nbsp;byte)&nbsp;(p&nbsp;:&nbsp;val)&nbsp;=&gt;<br/>
&nbsp;&nbsp;!!&nbsp;(~&nbsp;In&nbsp;Byte.zero&nbsp;s)&nbsp;&amp;&amp;<br/>
&nbsp;&nbsp;data_at&nbsp;sh&nbsp;(tarray&nbsp;tschar&nbsp;(Zlength&nbsp;s&nbsp;+&nbsp;1))&nbsp;(map&nbsp;Vbyte&nbsp;(s++<span class="inlinecode"><span class="id" type="var">Byte.zero</span></span>))&nbsp;p&nbsp;*)</span><br/>
</div>

<div class="doc">
Here is an example of a <span class="inlinecode"><span class="id" type="var">cstring</span></span> predicate that says, At address
   <span class="inlinecode"><span class="id" type="var">p</span></span> there is a null-terminated string representing "Hello".  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> (<span class="id" type="var">cstring</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">Hello'</span> <span class="id" type="var">p</span>). <span class="comment">(*&nbsp;:&nbsp;mpred&nbsp;*)</span><br/>
</div>

<div class="doc">
By unfolding the definition of <span class="inlinecode"><span class="id" type="var">cstring</span></span> this is equivalent to, 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> (<br/>
&nbsp;&nbsp;!! (¬<span class="id" type="var">In</span> <span class="id" type="var">Byte.zero</span> <span class="id" type="var">Hello'</span>) &amp;&amp;<br/>
&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">Tsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> (5 + 1)) (<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">Hello'</span>++[<span class="id" type="var">Byte.zero</span>])) <span class="id" type="var">p</span> ).<br/>
</div>

<div class="doc">
This says, no element of the list <span class="inlinecode"><span class="id" type="var">Hello'</span></span> is equal to <span class="inlinecode"><span class="id" type="var">Byte.zero</span></span>.
    In memory at address <span class="inlinecode"><span class="id" type="var">p</span></span> there is an array of 6 bytes, whose
    contents are the contents of <span class="inlinecode"><span class="id" type="var">Hello'</span></span> with a <span class="inlinecode"><span class="id" type="var">Byte.zero</span></span> appended
    at the end. 
<div class="paragraph"> </div>

 Sometimes we know that there is a null-terminated string inside an
    array of length <span class="inlinecode"><span class="id" type="var">n</span></span>.  That is, there are <span class="inlinecode"><span class="id" type="var">k</span></span> nonnull characters
    (where <span class="inlinecode"><span class="id" type="var">k</span>&lt;<span class="id" type="var">n</span></span>), followed by a null character, followed by <span class="inlinecode"><span class="id" type="var">n</span>-(<span class="id" type="var">k</span>+1)</span>
    uninitialized (or don't-care) characters.  We represent this with
    the <span class="inlinecode"><span class="id" type="var">cstringn</span></span> predicate. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">cstringn</span>. <span class="comment">(*&nbsp;=<br/>
&nbsp;fun&nbsp;{CS&nbsp;:&nbsp;compspecs}&nbsp;(sh&nbsp;:&nbsp;Share.t)&nbsp;(s&nbsp;:&nbsp;list&nbsp;byte)&nbsp;(n&nbsp;:&nbsp;Z)&nbsp;(p&nbsp;:&nbsp;val)&nbsp;=&gt;<br/>
&nbsp;!!&nbsp;(~&nbsp;In&nbsp;Byte.zero&nbsp;s)&nbsp;&amp;&amp;<br/>
&nbsp;data_at&nbsp;sh&nbsp;(tarray&nbsp;tschar&nbsp;n)<br/>
&nbsp;&nbsp;(map&nbsp;Vbyte&nbsp;(s&nbsp;++&nbsp;<span class="inlinecode"><span class="id" type="var">Byte.zero</span></span>)&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;list_repeat&nbsp;(Z.to_nat&nbsp;(n&nbsp;-&nbsp;(Zlength&nbsp;s&nbsp;+&nbsp;1)))&nbsp;Vundef)&nbsp;p&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">cstringn</span> <span class="id" type="var">Tsh</span> <span class="id" type="var">Hello'</span> 10 <span class="id" type="var">p</span>). <span class="comment">(*&nbsp;:&nbsp;mpred&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">End</span> <span class="id" type="var">StringDemo</span>.<br/>
</div>

<div class="doc">
<a name="lab102"></a><h2 class="section">Reasoning about the contents of C strings</h2>

<div class="paragraph"> </div>

 In separation logic proofs about C strings, we often find
  proof goals similar to the one exemplified by this lemma: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">demonstrate_cstring1</span>: <br/>
&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">i</span> <span class="id" type="var">contents</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H</span>:  ¬<span class="id" type="var">In</span> <span class="id" type="var">Byte.zero</span> <span class="id" type="var">contents</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H<sub>0</sub></span>: <span class="id" type="var">Znth</span> <span class="id" type="var">i</span> (<span class="id" type="var">contents</span> ++ [<span class="id" type="var">Byte.zero</span>]) ≠ <span class="id" type="var">Byte.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H<sub>1</sub></span>: 0 ≤ <span class="id" type="var">i</span> ≤ <span class="id" type="var">Zlength</span> <span class="id" type="var">contents</span>),<br/>
&nbsp;&nbsp;&nbsp;0 ≤ <span class="id" type="var">i</span> + 1 &lt; <span class="id" type="var">Zlength</span> (<span class="id" type="var">contents</span> ++ [<span class="id" type="var">Byte.zero</span>]).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

   A null-terminated string is an array of characters with three parts:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The contents of the string, none of which is the '\0' character;

</li>
<li> The null termination character, equal to Byte.zero;

</li>
<li> the remaining garbage in the array, after the null.

</li>
</ul>
   When processing a string, you should maintain three kinds of 
   assumptions above the line:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Hypothesis <span class="inlinecode"><span class="id" type="var">H</span></span> above the line says that none of the

</li>
</ul>
  contents is the null character;

<div class="paragraph"> </div>

<ul class="doclist">
<li> Hypothesis <span class="inlinecode"><span class="id" type="var">H<sub>0</sub></span></span> typically comes from a loop test, <span class="inlinecode"><span class="id" type="var">s</span>[<span class="id" type="var">i</span>]!=0</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">H<sub>1</sub></span></span> typically comes from a loop invariant:  suppose a 

</li>
</ul>
  a loop iteration variable <span class="inlinecode"><span class="id" type="var">_i</span></span> (with value <span class="inlinecode"><span class="id" type="var">i</span></span>)
  is traversing the array.  We expect that loop to go up to but 
  no farther than the null character, that is, one past the contents.

<div class="paragraph"> </div>

  The <span class="inlinecode"><span class="id" type="var">cstring</span></span> tactic processes all three of these hypotheses to conclude
  that <span class="inlinecode"><span class="id" type="var">i</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H<sub>7</sub></span>: <span class="id" type="var">i</span> &lt; <span class="id" type="var">Zlength</span> <span class="id" type="var">contents</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">cstring</span>.<br/>
</div>

<div class="doc">
But actually, <span class="inlinecode"><span class="id" type="var">cstring</span></span> tactic will prove any rep_omega consequence
   of that fact.  For example: 
</div>
<div class="code code-tight">
<span class="id" type="tactic">clear</span> <span class="id" type="var">H<sub>7</sub></span>.<br/>
<span class="id" type="var">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">sublist</span>.<br/>
<span class="id" type="var">cstring</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Here is another demonstration.  When your loop on the string
   contents reaches the end, the loop test <span class="inlinecode"><span class="id" type="var">s</span>[<span class="id" type="var">i</span>]!=0</span> is false, so
   therefore <span class="inlinecode"><span class="id" type="var">s</span>[<span class="id" type="var">i</span>]=0</span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">demonstrate_cstring2</span>: <br/>
&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">i</span> <span class="id" type="var">contents</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H</span>: ¬<span class="id" type="var">In</span> <span class="id" type="var">Byte.zero</span> <span class="id" type="var">contents</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H<sub>0</sub></span>: <span class="id" type="var">Znth</span> <span class="id" type="var">i</span> (<span class="id" type="var">contents</span> ++ [<span class="id" type="var">Byte.zero</span>]) = <span class="id" type="var">Byte.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">H<sub>1</sub></span>: 0 ≤ <span class="id" type="var">i</span> ≤ <span class="id" type="var">Zlength</span> <span class="id" type="var">contents</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">i</span> = <span class="id" type="var">Zlength</span> <span class="id" type="var">contents</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
Hypothesis <span class="inlinecode"><span class="id" type="var">H<sub>0</sub></span></span> expresses that the loop test determined <span class="inlinecode"><span class="id" type="var">s</span>[<span class="id" type="var">i</span>]=0</span>.
   The <span class="inlinecode"><span class="id" type="var">cstring</span></span> can then prove that <span class="inlinecode"><span class="id" type="var">i</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Zlength</span></span> <span class="inlinecode"><span class="id" type="var">contents</span></span>.  
</div>
<div class="code code-tight">
<span class="id" type="var">cstring</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab103"></a><h2 class="section">Function specs</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">strlen</span>(<span class="id" type="var">s</span>)</span> returns the length of the string <span class="inlinecode"><span class="id" type="var">s</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">strlen_spec</span> :=<br/>
&nbsp;<span class="id" type="var">DECLARE</span> <span class="id" type="var">_strlen</span><br/>
&nbsp;&nbsp;<span class="id" type="var">WITH</span> <span class="id" type="var">sh</span>: <span class="id" type="var">share</span>, <span class="id" type="var">s</span> : <span class="id" type="var">list</span> <span class="id" type="var">byte</span>, <span class="id" type="var">str</span>: <span class="id" type="var">val</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span> [ <span class="id" type="var">_str</span> <span class="id" type="var">OF</span> <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> (<span class="id" type="var">readable_share</span> <span class="id" type="var">sh</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_str</span> <span class="id" type="var">str</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">cstring</span> <span class="id" type="var">sh</span> <span class="id" type="var">s</span> <span class="id" type="var">str</span>)<br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">ret_temp</span> (<span class="id" type="var">Vptrofs</span> (<span class="id" type="var">Ptrofs.repr</span> (<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">cstring</span> <span class="id" type="var">sh</span> <span class="id" type="var">s</span> <span class="id" type="var">str</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">strcpy</span>(<span class="id" type="keyword">dest</span>,<span class="id" type="var">src</span>)</span> copies the string <span class="inlinecode"><span class="id" type="var">src</span></span> to the array <span class="inlinecode"><span class="id" type="keyword">dest</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">strcpy_spec</span> :=<br/>
&nbsp;<span class="id" type="var">DECLARE</span> <span class="id" type="var">_strcpy</span><br/>
&nbsp;&nbsp;<span class="id" type="var">WITH</span> <span class="id" type="var">wsh</span>: <span class="id" type="var">share</span>, <span class="id" type="var">rsh</span>: <span class="id" type="var">share</span>, <span class="id" type="keyword">dest</span> : <span class="id" type="var">val</span>, <span class="id" type="var">n</span> : <span class="id" type="var">Z</span>, <span class="id" type="var">src</span> : <span class="id" type="var">val</span>, <span class="id" type="var">s</span> : <span class="id" type="var">list</span> <span class="id" type="var">byte</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span> [ <span class="id" type="var">_dest</span> <span class="id" type="var">OF</span> <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span>, <span class="id" type="var">_src</span> <span class="id" type="var">OF</span> <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> (<span class="id" type="var">writable_share</span> <span class="id" type="var">wsh</span>; <span class="id" type="var">readable_share</span> <span class="id" type="var">rsh</span>; <span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> &lt; <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_dest</span> <span class="id" type="keyword">dest</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_src</span> <span class="id" type="var">src</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">data_at_</span> <span class="id" type="var">wsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>) <span class="id" type="keyword">dest</span>; <span class="id" type="var">cstring</span> <span class="id" type="var">rsh</span> <span class="id" type="var">s</span> <span class="id" type="var">src</span>)<br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">ret_temp</span> <span class="id" type="keyword">dest</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">cstringn</span> <span class="id" type="var">wsh</span> <span class="id" type="var">s</span> <span class="id" type="var">n</span> <span class="id" type="keyword">dest</span>; <span class="id" type="var">cstring</span> <span class="id" type="var">rsh</span> <span class="id" type="var">s</span> <span class="id" type="var">src</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">strcmp</span>(<span class="id" type="var">s<sub>1</sub></span>,<span class="id" type="var">s<sub>2</sub></span>)</span> compares strings s<sub>1</sub> and s<sub>2</sub> for lexicographic
  order.  This funspec is an underspecification of the actual
  behavior, in that it specifies equality testing only. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">strcmp_spec</span> :=<br/>
&nbsp;<span class="id" type="var">DECLARE</span> <span class="id" type="var">_strcmp</span><br/>
&nbsp;&nbsp;<span class="id" type="var">WITH</span> <span class="id" type="var">sh<sub>1</sub></span>: <span class="id" type="var">share</span>, <span class="id" type="var">sh<sub>2</sub></span>: <span class="id" type="var">share</span>, <span class="id" type="var">str1</span> : <span class="id" type="var">val</span>, <span class="id" type="var">s<sub>1</sub></span> : <span class="id" type="var">list</span> <span class="id" type="var">byte</span>, <span class="id" type="var">str2</span> : <span class="id" type="var">val</span>, <span class="id" type="var">s<sub>2</sub></span> : <span class="id" type="var">list</span> <span class="id" type="var">byte</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span> [ <span class="id" type="var">_str1</span> <span class="id" type="var">OF</span> <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span>, <span class="id" type="var">_str2</span> <span class="id" type="var">OF</span> <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> (<span class="id" type="var">readable_share</span> <span class="id" type="var">sh<sub>1</sub></span>; <span class="id" type="var">readable_share</span> <span class="id" type="var">sh<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_str1</span> <span class="id" type="var">str1</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_str2</span> <span class="id" type="var">str2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">cstring</span> <span class="id" type="var">sh<sub>1</sub></span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">str1</span>; <span class="id" type="var">cstring</span> <span class="id" type="var">sh<sub>2</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">str2</span>)<br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ <span class="id" type="var">tint</span> ]<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">EX</span> <span class="id" type="var">i</span> : <span class="id" type="var">int</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> (<span class="id" type="keyword">if</span> <span class="id" type="var">Int.eq_dec</span> <span class="id" type="var">i</span> <span class="id" type="var">Int.zero</span> <span class="id" type="keyword">then</span> <span class="id" type="var">s<sub>1</sub></span> = <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="keyword">else</span> <span class="id" type="var">s<sub>1</sub></span> ≠ <span class="id" type="var">s<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">ret_temp</span> (<span class="id" type="var">Vint</span> <span class="id" type="var">i</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">cstring</span> <span class="id" type="var">sh<sub>1</sub></span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">str1</span>; <span class="id" type="var">cstring</span> <span class="id" type="var">sh<sub>2</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">str2</span>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Gprog</span> : <span class="id" type="var">funspecs</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ltac</span>:(<span class="id" type="var">with_library</span> <span class="id" type="var">prog</span> [ <span class="id" type="var">strlen_spec</span>; <span class="id" type="var">strcpy_spec</span>; <span class="id" type="var">strcmp_spec</span> ]).<br/>
</div>

<div class="doc">
<a name="lab104"></a><h2 class="section">Proof of the <span class="inlinecode"><span class="id" type="var">strlen</span></span> function</h2>

<div class="paragraph"> </div>

<a name="lab105"></a><h4 class="section">Exercise: 2 stars, standard (body_strlen)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_strlen</span>: <span class="id" type="var">semax_body</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span> <span class="id" type="var">f_strlen</span> <span class="id" type="var">strlen_spec</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">start_function</span>.<br/>
</div>

<div class="doc">
Look at the proof goal below the line.  We have the assertion,

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">PROP</span>&nbsp;(&nbsp;)&nbsp;&nbsp;<span class="id" type="var">LOCAL</span>&nbsp;(<span class="id" type="var">temp</span>&nbsp;<span class="id" type="var">_str</span>&nbsp;<span class="id" type="var">str</span>)&nbsp;&nbsp;<span class="id" type="var">SEP</span>&nbsp;(<span class="id" type="var">cstring</span>&nbsp;<span class="id" type="var">sh</span>&nbsp;<span class="id" type="var">s</span>&nbsp;<span class="id" type="var">str</span>))
<div class="paragraph"> </div>

</div>
 When proving things about a string-manipulating function, the
  first decision is:  Does this function treat the string <i>abstractly</i>
  or does it subscript the array and look at the individual characters?

<div class="paragraph"> </div>

<ul class="doclist">
<li> If abstract, then we should <i>not</i> unfold the definition <span class="inlinecode"><span class="id" type="var">cstring</span></span>.

</li>
<li> If we subscript the array directly, we <i>must</i> unfold <span class="inlinecode"><span class="id" type="var">cstring</span></span>.

</li>
</ul>
  Since this <span class="inlinecode"><span class="id" type="var">strlen</span></span> function does access the array contents, we
  start by unfolding <span class="inlinecode"><span class="id" type="var">cstring</span></span>.
</div>
<div class="code code-tight">
<span class="id" type="tactic">unfold</span> <span class="id" type="var">cstring</span> <span class="id" type="keyword">in</span> *.<br/>
</div>

<div class="doc">
Now, we have a <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>osition  <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">In</span></span> <span class="inlinecode"><span class="id" type="var">Byte.zero</span></span> <span class="inlinecode"><span class="id" type="var">s</span></span> in the <span class="inlinecode"><span class="id" type="var">SEP</span></span>
    clause of our assertion; we can move it above the line by <span class="inlinecode"><span class="id" type="var">Intros</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="var">Intros</span>.<br/>
<span class="id" type="var">forward</span>. <span class="comment">(*&nbsp;i=0;&nbsp;*)</span><br/>
</div>

<div class="doc">
Now we are at a for-loop.  Unlike a simple while-loop, a for-loop may:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">break</span>;</span> (prematurely terminate the loop)

</li>
<li> <span class="inlinecode"><span class="id" type="var">continue</span>;</span> (prematurely terminate the body, skipping to the increment)

</li>
</ul>
 So therefore the simple Hoare-logic <i>while</i> rule is not always applicable.
 The general form of Verifiable C's loop tactic is:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">forward_loop</span>&nbsp;<span class="id" type="var">Inv1</span>&nbsp;&nbsp;<span class="id" type="var">continue</span>:&nbsp;<span class="id" type="var">Inv2</span>&nbsp;<span class="id" type="var">break</span>:&nbsp;<span class="id" type="var">Inv3</span>
<div class="paragraph"> </div>

</div>
  where <span class="inlinecode"><span class="id" type="var">Inv1</span></span> is the invariant that holds right before the loop test,
  <span class="inlinecode"><span class="id" type="var">Inv2</span></span> is the invariant that holds right before the increment, and
  <span class="inlinecode"><span class="id" type="var">Inv3</span></span> is the postcondition of the loop.

<div class="paragraph"> </div>

  Providing  <span class="inlinecode"><span class="id" type="var">continue</span>:</span> <span class="inlinecode"><span class="id" type="var">Inv2</span></span> is optional, as is <span class="inlinecode"><span class="id" type="var">break</span>:</span> <span class="inlinecode"><span class="id" type="var">Inv3</span></span>.
  In many cases the <span class="inlinecode"><span class="id" type="var">forward_loop</span></span> tactic can figure out that
  the <span class="inlinecode"><span class="id" type="var">continue</span>:</span> invariant is not needed (if the loop doesn't contain
  a <span class="inlinecode"><span class="id" type="var">continue</span></span> statement), or the <span class="inlinecode"><span class="id" type="var">break</span>:</span> postcondition is not needed
  (if there's no <span class="inlinecode"><span class="id" type="var">break</span></span> statement, or if there are no commands after
  the loop).

<div class="paragraph"> </div>

  So let's try this loop with only a single loop invariant:

</div>
<div class="code code-tight">
<span class="id" type="var">forward_loop</span>  (<span class="id" type="var">EX</span> <span class="id" type="var">i</span> : <span class="id" type="var">Z</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">PROP</span> (0 ≤ <span class="id" type="var">i</span> &lt; <span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> + 1)<br/>
&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_str</span> <span class="id" type="var">str</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_i</span> (<span class="id" type="var">Vptrofs</span> (<span class="id" type="var">Ptrofs.repr</span> <span class="id" type="var">i</span>)))<br/>
&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> (<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> + 1))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">s</span> ++ [<span class="id" type="var">Byte.zero</span>])) <span class="id" type="var">str</span>)).<br/>
</div>

<div class="doc">
Look at the <span class="inlinecode"><span class="id" type="var">LOCAL</span></span> clause that binds <span class="inlinecode"><span class="id" type="var">temp</span></span> <span class="inlinecode"><span class="id" type="var">_i</span></span> to the value
   <span class="inlinecode"><span class="id" type="var">Vptrofs</span></span> <span class="inlinecode">(<span class="id" type="var">Ptrofs.repr</span></span> <span class="inlinecode"><span class="id" type="var">i</span>)</span>.  What is that?  The answer is,
   in reasoning about C programs, we need:

<div class="paragraph"> </div>

<ul class="doclist">
<li> 8-bit integers, <span class="inlinecode"><span class="id" type="var">Byte.int</span></span> or simply <span class="inlinecode"><span class="id" type="var">byte</span></span>

</li>
<li> 32-bit integers, <span class="inlinecode"><span class="id" type="var">Int.int</span></span> or simply <span class="inlinecode"><span class="id" type="var">int</span></span>

</li>
<li> 64-bit integers, <span class="inlinecode"><span class="id" type="var">Int64.int</span></span>

</li>
</ul>
  But there is also the concept expressed in C as <span class="inlinecode"><span class="id" type="var">size_t</span></span>, that is,
  <i>The integer type with the same number of bits as a pointer</i>.
  In this might be the same as 32-bit int, or it might be the same
  as 64-bit int.

<div class="paragraph"> </div>

  So, just as CompCert has the <span class="inlinecode"><span class="id" type="var">Int</span></span> module for reasoning about 32-bit
  integers and the Int64 module for 64-bit integers, it has also
  the <span class="inlinecode"><span class="id" type="var">Ptrofs</span></span> module for reasoning about <i>pointer offsets</i>.  <span class="inlinecode"><span class="id" type="var">Ptrofs</span></span>
  is isomorphic to (but not identical to) either <span class="inlinecode"><span class="id" type="var">Int64</span></span> or <span class="inlinecode"><span class="id" type="var">Int</span></span>,
  depending on the boolean value <span class="inlinecode"><span class="id" type="var">Archi.ptr64</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="var">Compute</span> <span class="id" type="var">Archi.ptr64</span>. <span class="comment">(*&nbsp;=&nbsp;false&nbsp;:&nbsp;bool&nbsp;*)</span><br/>
</div>

<div class="doc">
This installation of Verifiable C is configured for 32-bit
   pointers.  But either way, to turn a <span class="inlinecode"><span class="id" type="var">Ptrofs.int</span></span> value into a
   CompCert <span class="inlinecode"><span class="id" type="var">val</span></span>, we have <span class="inlinecode"><span class="id" type="var">Vptrofs</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Print</span> <span class="id" type="var">Vptrofs</span>. <span class="comment">(*&nbsp;=&nbsp;<br/>
&nbsp;fun&nbsp;n&nbsp;:&nbsp;ptrofs&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;if&nbsp;Archi.ptr64&nbsp;then&nbsp;Vlong&nbsp;(Ptrofs.to_int64&nbsp;n)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;Vint&nbsp;(Ptrofs.to_int&nbsp;n)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ptrofs&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;val&nbsp;&nbsp;*)</span><br/>
</div>

<div class="doc">
And therefore, <span class="inlinecode"><span class="id" type="var">_i</span></span> is a C variable of type <span class="inlinecode"><span class="id" type="var">size_t</span></span>, 
  <span class="inlinecode"><span class="id" type="var">i</span></span> is a Coq variable of type <span class="inlinecode"><span class="id" type="var">Z</span></span>, and and <span class="inlinecode"><span class="id" type="var">Vptrofs</span></span> <span class="inlinecode">(<span class="id" type="var">Ptrofs.repr</span></span> <span class="inlinecode"><span class="id" type="var">i</span>)</span>
  is a CompCert <span class="inlinecode"><span class="id" type="var">val</span></span> that <i>represents</i> <span class="inlinecode"><span class="id" type="var">i</span></span> as a <span class="inlinecode"><span class="id" type="var">val</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="tactic">assert</span> (<span class="id" type="keyword">Example</span>: <span style='font-size:120%;'>&forall;</span><span class="id" type="var">n</span>, <span class="id" type="var">Vptrofs</span> (<span class="id" type="var">Ptrofs.repr</span> <span class="id" type="var">n</span>) = <span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> <span class="id" type="var">n</span>)). {<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;assertion&nbsp;holds&nbsp;in&nbsp;a&nbsp;32-bit&nbsp;C&nbsp;system.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">hint</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">autorewrite</span> <span class="id" type="keyword">with</span> <span class="id" type="var">norm</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">auto</span>.<br/>
} <span class="id" type="tactic">clear</span> <span class="id" type="keyword">Example</span>.<br/>
</div>

<div class="doc">
Now it's time to prove all the subgoals of <span class="inlinecode"><span class="id" type="var">forward_loop</span></span>. 
</div>
<div class="code code-tight">
* <span class="comment">(*&nbsp;Prove&nbsp;the&nbsp;precondition&nbsp;entails&nbsp;the&nbsp;loop&nbsp;invariant&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>
* <span class="comment">(*&nbsp;Prove&nbsp;the&nbsp;loop&nbsp;body&nbsp;preserves&nbsp;the&nbsp;invariant&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab106"></a><h2 class="section">Proof of the <span class="inlinecode"><span class="id" type="var">strcpy</span></span> function</h2>

<div class="paragraph"> </div>

<a name="lab107"></a><h4 class="section">Exercise: 2 stars, standard (strcpy_then_clause)</h4>
 The next lemma, or some variation of it, will be useful in the
   proof of the <span class="inlinecode"><span class="id" type="var">strcpy</span></span> function (in the <i>then</i> clause of the <i>if</i>
   statement). 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">strcpy_then_clause</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>(<span class="id" type="var">wsh</span>: <span class="id" type="var">share</span>) (<span class="id" type="keyword">dest</span>: <span class="id" type="var">val</span>) (<span class="id" type="var">n</span>: <span class="id" type="var">Z</span>) (<span class="id" type="var">s</span>: <span class="id" type="var">list</span> <span class="id" type="var">byte</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> &lt; <span class="id" type="var">n</span> →<br/>
&nbsp;&nbsp;¬<span class="id" type="var">In</span> <span class="id" type="var">Byte.zero</span> <span class="id" type="var">s</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">wsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">sublist</span> 0 (<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span>) <span class="id" type="var">s</span>) ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">upd_Znth</span> 0 (<span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span> - <span class="id" type="var">Zlength</span> <span class="id" type="var">s</span>)) <span class="id" type="var">Vundef</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> (<span class="id" type="var">Byte.signed</span> (<span class="id" type="var">Znth</span> (<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span>) (<span class="id" type="var">s</span> ++ [<span class="id" type="var">Byte.zero</span>]))))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">dest</span><br/>
&nbsp;&nbsp;&#x22A2;- <span class="id" type="var">data_at</span> <span class="id" type="var">wsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">s</span> ++ [<span class="id" type="var">Byte.zero</span>]) ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span> - (<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> + 1))) <span class="id" type="var">Vundef</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">dest</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">derives_refl'</span>.<br/>
<span class="id" type="tactic">f_equal</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">list_repeat_app'</span>. <span class="comment">(*&nbsp;Hint:&nbsp;this&nbsp;lemma&nbsp;will&nbsp;be&nbsp;useful.&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">upd_Znth_app1</span>. <span class="comment">(*&nbsp;Hint:&nbsp;this&nbsp;lemma&nbsp;will&nbsp;be&nbsp;useful.&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">app_Znth2</span>. <span class="comment">(*&nbsp;Hint:&nbsp;this&nbsp;lemma&nbsp;will&nbsp;be&nbsp;useful.&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">Znth_0_cons</span>. <span class="comment">(*&nbsp;Hint:&nbsp;this&nbsp;lemma&nbsp;will&nbsp;be&nbsp;useful.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Other&nbsp;useful&nbsp;lemmas&nbsp;will&nbsp;be&nbsp;map_app,&nbsp;app_ass&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab108"></a><h4 class="section">Exercise: 2 stars, standard (strcpy_else_clause)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">strcpy_else_clause</span>: <span style='font-size:120%;'>&forall;</span><span class="id" type="var">wsh</span> <span class="id" type="keyword">dest</span> <span class="id" type="var">n</span> <span class="id" type="var">s</span> <span class="id" type="var">i</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> &lt; <span class="id" type="var">n</span> →<br/>
&nbsp;&nbsp;¬<span class="id" type="var">In</span> <span class="id" type="var">Byte.zero</span> <span class="id" type="var">s</span> →<br/>
&nbsp;&nbsp;0 ≤ <span class="id" type="var">i</span> &lt; <span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> + 1 →<br/>
&nbsp;&nbsp;<span class="id" type="var">Znth</span> <span class="id" type="var">i</span> (<span class="id" type="var">s</span> ++ [<span class="id" type="var">Byte.zero</span>]) ≠ <span class="id" type="var">Byte.zero</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">wsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">upd_Znth</span> <span class="id" type="var">i</span> (<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">sublist</span> 0 <span class="id" type="var">i</span> <span class="id" type="var">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span> - <span class="id" type="var">i</span>)) <span class="id" type="var">Vundef</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> (<span class="id" type="var">Byte.signed</span> (<span class="id" type="var">Znth</span> <span class="id" type="var">i</span> (<span class="id" type="var">s</span> ++ [<span class="id" type="var">Byte.zero</span>])))))) <span class="id" type="keyword">dest</span><br/>
&nbsp;&nbsp;&#x22A2;- <span class="id" type="var">data_at</span> <span class="id" type="var">wsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">sublist</span> 0 (<span class="id" type="var">i</span> + 1) <span class="id" type="var">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span> - (<span class="id" type="var">i</span> + 1))) <span class="id" type="var">Vundef</span>) <span class="id" type="keyword">dest</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">derives_refl'</span>.<br/>
<span class="id" type="tactic">f_equal</span>.<br/>
</div>

<div class="doc">
Useful lemmas here will be: upd_Znth_app2, sublist_split,
list_repeat_app', app_Znth1, map_app, app_ass, sublist_len_1. 
</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab109"></a><h3 class="section">data_at is not injective!</h3>
 The <span class="inlinecode"><span class="id" type="var">Vundef</span></span> value means <i>uninitialized</i> or <i>undefined</i> or
   <i>defined but don't care</i>.  Consider this lemma: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">data_at_Vundef_example</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">i</span> <span class="id" type="var">n</span> <span class="id" type="var">sh</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;0 ≤ <span class="id" type="var">i</span> &lt; <span class="id" type="var">n</span> →<br/>
&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">i</span>+1)) (<span class="id" type="var">Vbyte</span> <span class="id" type="var">Byte.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span>-(<span class="id" type="var">i</span>+1))) <span class="id" type="var">Vundef</span>) <span class="id" type="var">p</span><br/>
&nbsp;&#x22A2;-           <br/>
&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> <span class="id" type="var">i</span>) (<span class="id" type="var">Vbyte</span> <span class="id" type="var">Byte.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span>-<span class="id" type="var">i</span>)) <span class="id" type="var">Vundef</span>) <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
The proof goal means: If cells <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" type="var">j</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">i</span>+1</span> are zero and cells
   <span class="inlinecode"><span class="id" type="var">i</span>+1</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" type="var">j</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">n</span></span> are don't care, that implies the weaker statement that
   cells <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" type="var">j</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">i</span></span> are zero and cells <span class="inlinecode"><span class="id" type="var">i</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" type="var">j</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">n</span></span> are don't-care.

<div class="paragraph"> </div>

   Now, let's try to prove it using the same technique as in
   <span class="inlinecode"><span class="id" type="var">strcpy_then_clause</span></span>: 
</div>
<div class="code code-tight">
<span class="id" type="tactic">apply</span> <span class="id" type="var">derives_refl'</span>.<br/>
<span class="id" type="tactic">f_equal</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">list_repeat_app'</span> <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="tactic">replace</span> (<span class="id" type="var">n</span>-<span class="id" type="var">i</span>) <span class="id" type="keyword">with</span> (1 + (<span class="id" type="var">n</span>-(<span class="id" type="var">i</span>+1))) <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">list_repeat_app'</span> <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="tactic">rewrite</span> !<span class="id" type="var">app_ass</span>.<br/>
<span class="id" type="tactic">f_equal</span>.<br/>
<span class="id" type="tactic">f_equal</span>.<br/>
</div>

<div class="doc">
Oops!  The current proof goal is False!  The problem was
that we should not have applied <span class="inlinecode"><span class="id" type="var">derives_refl'</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Abort</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">data_at_Vundef_example</span>:<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">i</span> <span class="id" type="var">n</span> <span class="id" type="var">sh</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;0 ≤ <span class="id" type="var">i</span> &lt; <span class="id" type="var">n</span> →<br/>
&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">i</span>+1)) (<span class="id" type="var">Vbyte</span> <span class="id" type="var">Byte.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span>-(<span class="id" type="var">i</span>+1))) <span class="id" type="var">Vundef</span>) <span class="id" type="var">p</span><br/>
&nbsp;&#x22A2;-           <br/>
&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> <span class="id" type="var">i</span>) (<span class="id" type="var">Vbyte</span> <span class="id" type="var">Byte.zero</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span>-<span class="id" type="var">i</span>)) <span class="id" type="var">Vundef</span>) <span class="id" type="var">p</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">list_repeat_app'</span> <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="tactic">replace</span> (<span class="id" type="var">n</span>-<span class="id" type="var">i</span>) <span class="id" type="keyword">with</span> (1 + (<span class="id" type="var">n</span>-(<span class="id" type="var">i</span>+1))) <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">list_repeat_app'</span> <span class="id" type="tactic">by</span> <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="tactic">rewrite</span> !<span class="id" type="var">app_ass</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">split2_data_at_Tarray_app</span>.<br/>
<span class="comment">(*&nbsp;&nbsp;forall&nbsp;(cs&nbsp;:&nbsp;compspecs)&nbsp;(mid&nbsp;n&nbsp;:&nbsp;Z)&nbsp;(sh&nbsp;:&nbsp;Share.t)&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(t&nbsp;:&nbsp;type)&nbsp;(v<sub>1</sub>&nbsp;v<sub>2</sub>&nbsp;:&nbsp;list&nbsp;(reptype&nbsp;t))&nbsp;(p&nbsp;:&nbsp;val),<br/>
&nbsp;&nbsp;Zlength&nbsp;v<sub>1</sub>&nbsp;=&nbsp;mid&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;Zlength&nbsp;v<sub>2</sub>&nbsp;=&nbsp;n&nbsp;-&nbsp;mid&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span><br/>
&nbsp;&nbsp;data_at&nbsp;sh&nbsp;(tarray&nbsp;t&nbsp;n)&nbsp;(v<sub>1</sub>&nbsp;++&nbsp;v<sub>2</sub>)&nbsp;p&nbsp;=<br/>
&nbsp;&nbsp;data_at&nbsp;sh&nbsp;(tarray&nbsp;t&nbsp;mid)&nbsp;v<sub>1</sub>&nbsp;p&nbsp;*<br/>
&nbsp;&nbsp;data_at&nbsp;sh&nbsp;(tarray&nbsp;t&nbsp;(n&nbsp;-&nbsp;mid))&nbsp;v<sub>2</sub><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(field_address0&nbsp;(tarray&nbsp;t&nbsp;n)&nbsp;<span class="inlinecode"><span class="id" type="var">ArraySubsc</span></span> <span class="inlinecode"><span class="id" type="var">mid</span></span>&nbsp;p)<br/>
*)</span><br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">split2_data_at_Tarray_app</span> <span class="id" type="var">i</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">list_solve</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">split2_data_at_Tarray_app</span> 1) <span class="id" type="tactic">by</span> <span class="id" type="var">list_solve</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">split2_data_at_Tarray_app</span> <span class="id" type="var">i</span>) <span class="id" type="tactic">by</span> <span class="id" type="var">list_solve</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">split2_data_at_Tarray_app</span> 1) <span class="id" type="tactic">by</span> <span class="id" type="var">list_solve</span>.<br/>
<span class="id" type="var">cancel</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Why did that work?  Let's look at a simpler example. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <span class="id" type="var">cancel_example</span>:<br/>
&nbsp;<span style='font-size:120%;'>&forall;</span><span class="id" type="var">sh</span> <span class="id" type="var">i</span> <span class="id" type="var">j</span> <span class="id" type="var">p</span> <span class="id" type="var">q</span>, <br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> <span class="id" type="var">tint</span> (<span class="id" type="var">Vint</span> <span class="id" type="var">i</span>) <span class="id" type="var">p</span> * <span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> <span class="id" type="var">tint</span> (<span class="id" type="var">Vint</span> <span class="id" type="var">j</span>) <span class="id" type="var">q</span><br/>
&nbsp;&#x22A2;- <span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> <span class="id" type="var">tint</span> (<span class="id" type="var">Vint</span> <span class="id" type="var">i</span>) <span class="id" type="var">p</span> * <span class="id" type="var">data_at</span> <span class="id" type="var">sh</span> <span class="id" type="var">tint</span> (<span class="id" type="var">Vundef</span>) <span class="id" type="var">q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>.<br/>
</div>

<div class="doc">
Uncomment the following line, and notice that it solves the goal. 
</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;cancel.&nbsp;*)</span><br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">cancel</span></span> breaks this into two subgoals: 
</div>
<div class="code code-tight">
<span class="id" type="tactic">apply</span> <span class="id" type="var">sepcon_derives</span>.<br/>
- <br/>
<span class="comment">(**&nbsp;In&nbsp;the&nbsp;first&nbsp;subgoal,&nbsp;we&nbsp;use&nbsp;the&nbsp;fact&nbsp;that&nbsp;&#x22A2;-&nbsp;is&nbsp;reflexive&nbsp;*)</span><br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">derives_refl</span>.<br/>
-<br/>
<span class="comment">(**&nbsp;In&nbsp;the&nbsp;second&nbsp;subgoal,&nbsp;we&nbsp;use&nbsp;the&nbsp;fact&nbsp;that&nbsp;_any_&nbsp;value<br/>
&nbsp;&nbsp;implies&nbsp;a&nbsp;Vundef,&nbsp;or&nbsp;more&nbsp;generally,&nbsp;_any_&nbsp;value&nbsp;implies<br/>
&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">default_val</span></span> <span class="inlinecode"><span class="id" type="var">t</span></span>&nbsp;for&nbsp;any&nbsp;CompCert&nbsp;type&nbsp;t.&nbsp;*)</span><br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">stronger_default_val</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The moral of the story is:  When proving 

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">sh</span>&nbsp;<span class="id" type="var">t</span>&nbsp;<span class="id" type="var">a</span>&nbsp;<span class="id" type="var">p</span>&nbsp;&#x22A2;-&nbsp;<span class="id" type="var">data_at</span>&nbsp;<span class="id" type="var">sh</span>&nbsp;<span class="id" type="var">t</span>&nbsp;<span class="id" type="var">b</span>&nbsp;<span class="id" type="var">p</span>
<div class="paragraph"> </div>

</div>
   if (a=b) you can simplify the goal using

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span>&nbsp;<span class="id" type="var">derives_refl'</span>;&nbsp;<span class="id" type="tactic">f_equal</span>.
<div class="paragraph"> </div>

</div>
   but if a is strictly more defined than b, then derives_refl' is not appropriate.

<div class="paragraph"> </div>

<a name="lab110"></a><h4 class="section">Exercise: 3 stars, standard (body_strcpy)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_strcpy</span>: <span class="id" type="var">semax_body</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span> <span class="id" type="var">f_strcpy</span> <span class="id" type="var">strcpy_spec</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">start_function</span>.<br/>
</div>

<div class="doc">
Because this function subscripts the strings, it does <i>not</i>
  treat the strings abstractly, we must unfold <span class="inlinecode"><span class="id" type="var">cstring</span></span> and <span class="inlinecode"><span class="id" type="var">cstringn</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="tactic">unfold</span> <span class="id" type="var">cstring</span>,<span class="id" type="var">cstringn</span> <span class="id" type="keyword">in</span> *.<br/>
<span class="id" type="var">forward</span>.<br/>
<span class="id" type="var">Intros</span>.<br/>
<span class="id" type="var">forward_loop</span> (<span class="id" type="var">EX</span> <span class="id" type="var">i</span> : <span class="id" type="var">Z</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">PROP</span> (0 ≤ <span class="id" type="var">i</span> &lt; <span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> + 1)<br/>
&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">_i</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> <span class="id" type="var">i</span>)); <span class="id" type="var">temp</span> <span class="id" type="var">_dest</span> <span class="id" type="keyword">dest</span>; <span class="id" type="var">temp</span> <span class="id" type="var">_src</span> <span class="id" type="var">src</span>)<br/>
&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">data_at</span> <span class="id" type="var">wsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">sublist</span> 0 <span class="id" type="var">i</span> <span class="id" type="var">s</span>) ++ <span class="id" type="var">list_repeat</span> (<span class="id" type="var">Z.to_nat</span> (<span class="id" type="var">n</span> - <span class="id" type="var">i</span>)) <span class="id" type="var">Vundef</span>) <span class="id" type="keyword">dest</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">data_at</span> <span class="id" type="var">rsh</span> (<span class="id" type="var">tarray</span> <span class="id" type="var">tschar</span> (<span class="id" type="var">Zlength</span> <span class="id" type="var">s</span> + 1)) (<span class="id" type="var">map</span> <span class="id" type="var">Vbyte</span> (<span class="id" type="var">s</span> ++ [<span class="id" type="var">Byte.zero</span>])) <span class="id" type="var">src</span>)).<br/>
+ <span class="comment">(*&nbsp;Prove&nbsp;the&nbsp;precondition&nbsp;implies&nbsp;the&nbsp;loop&nbsp;invariant&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>
+ <span class="comment">(*&nbsp;Prove&nbsp;the&nbsp;loop&nbsp;body&nbsp;*)</span><br/>
<span class="comment">(**&nbsp;In&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">then</span></span>&nbsp;clause&nbsp;of&nbsp;this&nbsp;proof,&nbsp;you&nbsp;may&nbsp;reach&nbsp;a&nbsp;proof&nbsp;goal<br/>
&nbsp;&nbsp;similar&nbsp;to&nbsp;Lemma&nbsp;strcpy_then_clause,&nbsp;but&nbsp;not&nbsp;identical.&nbsp;&nbsp;In&nbsp;that<br/>
&nbsp;&nbsp;case&nbsp;you&nbsp;may&nbsp;want&nbsp;to&nbsp;use&nbsp;the&nbsp;same&nbsp;proof&nbsp;techniques&nbsp;you&nbsp;used&nbsp;in&nbsp;that<br/>
&nbsp;&nbsp;exercise.&nbsp;&nbsp;Ditto&nbsp;for&nbsp;the&nbsp;else&nbsp;clause,&nbsp;and&nbsp;strcpy_else_clause.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab111"></a><h4 class="section">Exercise: 3 stars, standard (example_call_strcpy)</h4>
 Prove the correctness of a function that calls <span class="inlinecode"><span class="id" type="var">strcpy</span></span>.
<pre>
  int example_call_strcpy(void) {
    char buf[10];
    strcpy(buf,"Hello");
    return buf[0];
  }
</pre>

</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <span class="id" type="var">stringlit_1_contents</span> := <span class="id" type="var">Hello'</span> ++ [<span class="id" type="var">Byte.zero</span>].<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">example_call_strcpy_spec</span> :=<br/>
&nbsp;<span class="id" type="var">DECLARE</span> <span class="id" type="var">_example_call_strcpy</span><br/>
&nbsp;&nbsp;<span class="id" type="var">WITH</span> <span class="id" type="var">gv</span>: <span class="id" type="var">globals</span><br/>
&nbsp;&nbsp;<span class="id" type="var">PRE</span> [  ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">gvars</span> <span class="id" type="var">gv</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">cstring</span> <span class="id" type="var">Ews</span> (<span class="id" type="var">Hello'</span> ++ [<span class="id" type="var">Byte.zero</span>]) (<span class="id" type="var">gv</span> <span class="id" type="var">___stringlit_1</span>))<br/>
&nbsp;&nbsp;<span class="id" type="var">POST</span> [ <span class="id" type="var">tptr</span> <span class="id" type="var">tschar</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">PROP</span> ()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">LOCAL</span> (<span class="id" type="var">temp</span> <span class="id" type="var">ret_temp</span> (<span class="id" type="var">Vint</span> (<span class="id" type="var">Int.repr</span> (<span class="id" type="var">Z.of_N</span> (<span class="id" type="var">Ascii.N_of_ascii</span> "H"%<span class="id" type="var">char</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SEP</span> (<span class="id" type="var">cstring</span> <span class="id" type="var">Ews</span> (<span class="id" type="var">Hello'</span> ++ [<span class="id" type="var">Byte.zero</span>]) (<span class="id" type="var">gv</span> <span class="id" type="var">___stringlit_1</span>)).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_example_call_strcpy</span>: <span class="id" type="var">semax_body</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span> <span class="id" type="var">f_example_call_strcpy</span> <span class="id" type="var">example_call_strcpy_spec</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">start_function</span>.<br/>
</div>

<div class="doc">
This proof is fairly straightforward.
  First, figure out what WITH witness to give for forward_call.
  Hint: look at the SEP clause of the precondition of strcpy_spec, and
  see how the <span class="inlinecode"><span class="id" type="var">data_at</span></span> and <span class="inlinecode"><span class="id" type="var">cstring</span></span> conjuncts must match your
  current assertion.

<div class="paragraph"> </div>

  Second, after the forward_call, don't forget to unfold <span class="inlinecode"><span class="id" type="var">cstringn</span></span>;
  this is necessary because the code after the call subscripts the
  <span class="inlinecode"><span class="id" type="var">_buf</span></span> array directly. 
</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab112"></a><h4 class="section">Exercise: 4 stars, standard, optional (body_strcmp)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">body_strcmp</span>: <span class="id" type="var">semax_body</span> <span class="id" type="var">Vprog</span> <span class="id" type="var">Gprog</span> <span class="id" type="var">f_strcmp</span> <span class="id" type="var">strcmp_spec</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<span class="comment">(*&nbsp;Wed&nbsp;Apr&nbsp;24&nbsp;08:45:37&nbsp;EDT&nbsp;2019&nbsp;*)</span><br/>
</div>
</div>



</div>

</body>
</html>